<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" media="screen" href="/~d/styles/atom10full.xsl"?>
<?xml-stylesheet type="text/css" media="screen" href="http://feeds.feedburner.com/~d/styles/itemcontent.css"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Elixir Lang</title>
  <link href="http://elixir-lang.org"/>
  <updated>2017-01-23T08:57:54+00:00</updated>
  <id>http://elixir-lang.org</id>
  <atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="self" type="application/atom+xml" href="http://feeds.feedburner.com/ElixirLang"/>
  <feedburner:info xmlns:feedburner="http://rssnamespace.org/feedburner/ext/1.0" uri="elixirlang"/>
  <atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="hub" href="http://pubsubhubbub.appspot.com/"/>
  <entry>
    <title>Elixir v1.4 released</title>
    <link href="http://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2017-01-05T00:00:00+00:00</updated>
    <id>/blog/2017/01/05/elixir-v1-4-0-released</id>
    <content type="html">&lt;p&gt;Elixir v1.4 brings new features, enhancements and bug fixes. The most notable changes are the addition of the &lt;code class="highlighter-rouge"&gt;Registry&lt;/code&gt; module, the &lt;code class="highlighter-rouge"&gt;Task.async_stream/3&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Task.async_stream/5&lt;/code&gt; function which aid developers in writing concurrent software, and the new application inference and commands added to Mix.&lt;/p&gt;

&lt;p&gt;In this post we will cover the main additions. The complete &lt;a href="https://github.com/elixir-lang/elixir/releases/tag/v1.4.0"&gt;release notes&lt;/a&gt; are also available.&lt;/p&gt;

&lt;h2 id="registry"&gt;Registry&lt;/h2&gt;

&lt;p&gt;The &lt;a href="https://hexdocs.pm/elixir/Registry.html"&gt;&lt;code class="highlighter-rouge"&gt;Registry&lt;/code&gt;&lt;/a&gt; is a new module in Elixir’s standard library that allows Elixir developers to implement patterns such as name lookups, code dispatching or even a pubsub system in a simple and scalable way.&lt;/p&gt;

&lt;p&gt;Broadly speaking, the Registry is a local, decentralized and scalable key-value process storage. Let’s break this in parts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Local because keys and values are only accessible to the current node (opposite to distributed)&lt;/li&gt;
  &lt;li&gt;Decentralized because there is no single entity responsible for managing the registry&lt;/li&gt;
  &lt;li&gt;Scalable because performance scales linearly with the addition of more cores upon partitioning&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A registry may have unique or duplicate keys. Every key-value pair is associated to the process registering the key. Keys are automatically removed once the owner process terminates. Starting, registering and looking up keys is quite straight-forward:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; Registry.start_link(:unique, MyRegistry)
iex&amp;gt; {:ok, _} = Registry.register(MyRegistry, "hello", 1)
iex&amp;gt; Registry.lookup(MyRegistry, "hello")
[{self(), 1}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, huge thanks to &lt;a href="https://twitter.com/voltonez"&gt;Bram Verburg&lt;/a&gt; who has performed &lt;a href="https://docs.google.com/spreadsheets/d/1MByRZJMCnZ1wPiLhBEnSRRSuy1QXp8kr27PIOXO3qqg/edit#gid=0"&gt;extensive benchmarks&lt;/a&gt; on the registry to show it scales linearly with the number of cores by increasing the number of partitions.&lt;/p&gt;

&lt;h2 id="syntax-coloring"&gt;Syntax coloring&lt;/h2&gt;

&lt;p&gt;Elixir v1.4 introduces the ability to syntax color inspected data structures and IEx automatically relies on this feature to provide syntax coloring for evaluated shell results:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/contents/iex-coloring.png" alt="IEx coloring" /&gt;&lt;/p&gt;

&lt;p&gt;This behaviour can be configured via the &lt;code class="highlighter-rouge"&gt;:syntax_colors&lt;/code&gt; coloring option:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;IEx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;colors:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;syntax_colors:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;atom:&lt;/span&gt; &lt;span class="ss"&gt;:cyan&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;string:&lt;/span&gt; &lt;span class="ss"&gt;:green&lt;/span&gt;&lt;span class="p"&gt;]]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To disable coloring altogether, simply pass an empty list to &lt;code class="highlighter-rouge"&gt;:syntax_colors&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="taskasyncstream"&gt;Task.async_stream&lt;/h2&gt;

&lt;p&gt;When there is a need to traverse a collection of items concurrently, Elixir developers often resort to tasks:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;collection&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="no"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;SomeMod&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:function&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;&amp;amp;1&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="no"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;await&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The snippet above will spawn a new task by invoking &lt;code class="highlighter-rouge"&gt;SomeMod.function(element)&lt;/code&gt; for every element in the collection and then await for the task results.&lt;/p&gt;

&lt;p&gt;However, the snippet above will spawn and run concurrently as many tasks as there are items in the collection. While this may be fine in many occasions, including small collections, sometimes it is necessary to restrict amount of tasks running concurrently, specially when shared resources are involved.&lt;/p&gt;

&lt;p&gt;Elixir v1.4 adds &lt;code class="highlighter-rouge"&gt;Task.async_stream/3&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Task.async_stream/5&lt;/code&gt; which brings some of the lessons we learned from &lt;a href="/blog/2016/07/14/announcing-genstage/"&gt;the GenStage project&lt;/a&gt; directly into Elixir:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;collection&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async_stream&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;SomeMod&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:function&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="ss"&gt;max_concurrency:&lt;/span&gt; &lt;span class="m"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The code above will also start the same &lt;code class="highlighter-rouge"&gt;SomeMod.function(element)&lt;/code&gt; task for every element in the collection except it will also guarantee we have at most 8 tasks being processed at the same time. You can use &lt;code class="highlighter-rouge"&gt;System.schedulers_online&lt;/code&gt; to retrieve the number of cores and balance the processing based on the amount of cores available.&lt;/p&gt;

&lt;p&gt;The &lt;code class="highlighter-rouge"&gt;Task.async_stream&lt;/code&gt; functions are also lazy, allowing developers to partially consume the stream until a condition is reached. Furthermore, &lt;code class="highlighter-rouge"&gt;Task.Supervisor.async_stream/4&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Task.Supervisor.async_stream/6&lt;/code&gt; can be used to ensure the concurrent tasks are spawned under a given supervisor.&lt;/p&gt;

&lt;h2 id="application-inference"&gt;Application inference&lt;/h2&gt;

&lt;p&gt;In previous Mix versions, most of your dependencies had to be added both to your dependencies list and applications list. Here is how a &lt;code class="highlighter-rouge"&gt;mix.exs&lt;/code&gt; would look like:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;application&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;applications:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:logger&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:plug&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:postgrex&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;deps&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:plug&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;~&amp;gt; 1.2"&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
   &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:postgrex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;~&amp;gt; 1.0"&lt;/span&gt;&lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This was a common source of confusion and quite error prone as many developers would not list their dependencies in the applications list.&lt;/p&gt;

&lt;p&gt;Mix v1.4 now automatically infers your applications list as long as you leave the &lt;code class="highlighter-rouge"&gt;:applications&lt;/code&gt; key empty. The &lt;code class="highlighter-rouge"&gt;mix.exs&lt;/code&gt; above can be rewritten to:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;application&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;extra_applications:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:logger&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;deps&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:plug&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;~&amp;gt; 1.2"&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
   &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:postgrex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;~&amp;gt; 1.0"&lt;/span&gt;&lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;With the above, Mix will automatically build your application list based on your dependencies. Developers now only need to specify which applications shipped as part of Erlang or Elixir that they require, such as &lt;code class="highlighter-rouge"&gt;:logger&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, if there is a dependency you don’t want to include in the application runtime list, you can do so by specifying the &lt;code class="highlighter-rouge"&gt;runtime: false&lt;/code&gt; option:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;:distillery,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;"&amp;gt; 0.0.0"&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;runtime&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We hope this feature provides a more streamlined workflow for developers who are building releases for their Elixir projects.&lt;/p&gt;

&lt;h2 id="mix-install-from-scm"&gt;Mix install from SCM&lt;/h2&gt;

&lt;p&gt;Mix v1.4 can now install escripts and archives from both Git and Hex, providing you with even more options for distributing Elixir code.&lt;/p&gt;

&lt;p&gt;This makes it possible to distribute CLI applications written in Elixir by publishing a package which builds an escript to Hex. &lt;a href="https://hex.pm/packages/ex_doc"&gt;&lt;code class="highlighter-rouge"&gt;ex_doc&lt;/code&gt;&lt;/a&gt; has been updated to serve as an example of how to use this new functionality.&lt;/p&gt;

&lt;p&gt;Simply running:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;mix escript.install hex ex_doc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;will fetch &lt;code class="highlighter-rouge"&gt;ex_doc&lt;/code&gt; and its dependencies, build them, and then install &lt;code class="highlighter-rouge"&gt;ex_doc&lt;/code&gt; to &lt;code class="highlighter-rouge"&gt;~/.mix/escripts&lt;/code&gt; (by default). After adding &lt;code class="highlighter-rouge"&gt;~/.mix/escripts&lt;/code&gt; to your &lt;code class="highlighter-rouge"&gt;PATH&lt;/code&gt;, running &lt;code class="highlighter-rouge"&gt;ex_doc&lt;/code&gt; is as simple as:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;ex_doc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can now also install archives from Hex in this way. Since they are fetched and built on the user’s machine, they do not have the same limitations as pre-built archives. However, keep in mind archives are loaded on every Mix command and may conflict with modules or dependencies in your projects. For this reason, escripts is the preferred format for sharing executables.&lt;/p&gt;

&lt;p&gt;It is also possible to install escripts and archives by providing a Git/GitHub repo. See &lt;code class="highlighter-rouge"&gt;mix help escript.install&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;mix help archive.install&lt;/code&gt; for more details.&lt;/p&gt;

&lt;h2 id="summing-up"&gt;Summing up&lt;/h2&gt;

&lt;p&gt;The full list of changes is available in our &lt;a href="https://github.com/elixir-lang/elixir/releases/tag/v1.4.0"&gt;release notes&lt;/a&gt;. Don’t forget to check &lt;a href="/install.html"&gt;the Install section&lt;/a&gt; to get Elixir installed and our &lt;a href="http://elixir-lang.org/getting-started/introduction.html"&gt;Getting Started guide&lt;/a&gt; to learn more.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Announcing GenStage</title>
    <link href="http://elixir-lang.org/blog/2016/07/14/announcing-genstage/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2016-07-14T00:00:00+00:00</updated>
    <id>/blog/2016/07/14/announcing-genstage</id>
    <content type="html">&lt;p&gt;Today we are glad to announce the official release of GenStage. GenStage is a new Elixir behaviour for exchanging events with back-pressure between Elixir processes. In the short-term, we expect GenStage to replace the use cases for GenEvent as well as providing a composable abstraction for consuming data from third-party systems.&lt;/p&gt;

&lt;p&gt;In this blog post we will cover the background that led us to GenStage, some example use cases, and what we are exploring for future releases. If instead you are looking for a quick reference, &lt;a href="https://github.com/elixir-lang/gen_stage"&gt;check the project source code&lt;/a&gt; and &lt;a href="https://hexdocs.pm/gen_stage/Experimental.GenStage.html"&gt;access its documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="background"&gt;Background&lt;/h2&gt;

&lt;p&gt;One of the original motivations for &lt;a href="https://www.youtube.com/watch?v=Lqo9-pQuRKE"&gt;creating and designing Elixir was to introduce better abstractions for working with collections&lt;/a&gt;. Not only that, we want to provide developers interested in manipulating collections with a path to take their code from eager to lazy, to concurrent and then distributed.&lt;/p&gt;

&lt;p&gt;Let’s discuss a simple but actual example: word counting. The idea of word counting is to receive one file and count how many times each word appears in the document. Using the &lt;code class="highlighter-rouge"&gt;Enum&lt;/code&gt; module it could be implemented as follows:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;File&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;path/to/some/file"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;\n"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flat_map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="no"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt; "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(%{},&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="no"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;While the solution above works fine and is efficient for small files, it is quite restrictive for large inputs as it loads the whole file into memory.&lt;/p&gt;

&lt;p&gt;Another issue with the solution above is that the &lt;code class="highlighter-rouge"&gt;Enum.flat_map/2&lt;/code&gt; step will build a huge list, with all the words in the file, before we effectively start counting them. Again, for a large document, this means more memory usage and a waste of processing time in building a list that will be traversed right after.&lt;/p&gt;

&lt;p&gt;Luckily, Elixir provides a solution to this problem (and has provided it for quite some time): streams. One of the advantage of streams is they are lazy, allowing us to traverse collections item by item, in this case, line by line, instead of loading the whole data set into memory. Let’s rewrite the example above to use streams:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;File&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stream!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;path/to/some/file"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flat_map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="no"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt; "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(%{},&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="no"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;By using &lt;code class="highlighter-rouge"&gt;File.stream!&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Stream.flat_map&lt;/code&gt;, we build a lazy computation that will emit a single line, break that line into words, and emit such words one by one without building huge lists in memory when enumerated. The functions in the &lt;a href="https://hexdocs.pm/elixir/Stream.html"&gt;Stream module&lt;/a&gt; just express the computation we want to perform. The computation itself, like traversing the file or breaking into words in &lt;code class="highlighter-rouge"&gt;flat_map&lt;/code&gt;, only happens when we call a function in the &lt;code class="highlighter-rouge"&gt;Enum&lt;/code&gt; module. We have covered &lt;a href="http://blog.plataformatec.com.br/2015/05/introducing-reducees/"&gt;the foundation for Enum and Streams&lt;/a&gt; in another article.&lt;/p&gt;

&lt;p&gt;The solution above allows us to work with large datasets without loading them all into memory. For large files, it is going to provide much better performance than the eager version. However, the solution above still does not leverage concurrency. For a machine with more than one core, which is the huge majority of machines we have available today, it is a suboptimal solution.&lt;/p&gt;

&lt;p&gt;That said, how could we leverage concurrency in the example above?&lt;/p&gt;

&lt;p&gt;During my ElixirConf 2015 keynote, &lt;a href="http://confreaks.tv/videos/elixirconf2015-keynote"&gt;I discussed one of the most immediate solutions to this problem&lt;/a&gt; which was to convert parts of your pipeline to separate processes:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;File&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stream!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;path/to/some/file"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flat_map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="no"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt; "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;# NEW!&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(%{},&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="no"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The idea is that &lt;code class="highlighter-rouge"&gt;Stream.async&lt;/code&gt; would run the previous computations in a separate process that would stream its messages to the process that called &lt;code class="highlighter-rouge"&gt;Enum.reduce&lt;/code&gt;. Unfortunately, the solution above is less than ideal.&lt;/p&gt;

&lt;p&gt;First of all, we want to avoid moving data between processes as much as possible. Instead, we want to start multiple processes that perform the same computation in parallel. Not only that, if we are requiring developers to place &lt;code class="highlighter-rouge"&gt;Stream.async&lt;/code&gt; manually, it may lead to inefficient and error prone solutions.&lt;/p&gt;

&lt;p&gt;Although the solution above has many flaws, it has helped us ask the right questions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If &lt;code class="highlighter-rouge"&gt;Stream.async&lt;/code&gt; is introducing new processes, how can we guarantee those processes are supervised?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Since we are exchanging messages between processes, how do we prevent a process from receiving too many messages? We need a back-pressure mechanism that allows the receiving process to specify how much it can handle from the sending process.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We have jumped through different abstractions trying to answer those questions until we have finally settled on GenStage.&lt;/p&gt;

&lt;h2 id="genstage"&gt;GenStage&lt;/h2&gt;

&lt;p&gt;GenStage is a new Elixir behaviour for exchanging events with back-pressure between Elixir processes. Developers who use GenStage only need to worry about how the data is produced, manipulated and consumed. The act of dispatching the data and providing back-pressure is completely abstracted away from the developers.&lt;/p&gt;

&lt;p&gt;As a quick example, let’s write a simple pipeline that will produce events as increasing numbers, multiply those numbers by two, and then print them to the terminal. We will do so by implementing three stages, the &lt;code class="highlighter-rouge"&gt;:producer&lt;/code&gt;, the &lt;code class="highlighter-rouge"&gt;:producer_consumer&lt;/code&gt; and the &lt;code class="highlighter-rouge"&gt;:consumer&lt;/code&gt;, which we will call &lt;code class="highlighter-rouge"&gt;A&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;B&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;C&lt;/code&gt; respectively. We will go back to the word counting example at the end of this post.&lt;/p&gt;

&lt;p&gt;Let’s start with the producer that we will call &lt;code class="highlighter-rouge"&gt;A&lt;/code&gt;. Since &lt;code class="highlighter-rouge"&gt;A&lt;/code&gt; is a producer, its main responsibility is to receive demand, which is the number of events the consumer is willing to handle, and generate events. Those events may be in memory or an external data source. For now let’s implement a simple counter starting from a given value of &lt;code class="highlighter-rouge"&gt;counter&lt;/code&gt; received on &lt;code class="highlighter-rouge"&gt;init/1&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;Note: all of the modules in the &lt;code class="highlighter-rouge"&gt;GenStage&lt;/code&gt; project are prefixed with the &lt;code class="highlighter-rouge"&gt;Experimental&lt;/code&gt; namespace. That’s why the examples below and your code should &lt;code class="highlighter-rouge"&gt;alias Experimental.GenStage&lt;/code&gt; at the top of your files.&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;alias&lt;/span&gt; &lt;span class="no"&gt;Experimental&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;GenStage&lt;/span&gt;

&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;A&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="no"&gt;GenStage&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:producer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;handle_demand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;demand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;when&lt;/span&gt; &lt;span class="n"&gt;demand&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="c1"&gt;# If the counter is 3 and we ask for 2 items, we will&lt;/span&gt;
    &lt;span class="c1"&gt;# emit the items 3 and 4, and set the state to 5.&lt;/span&gt;
    &lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;demand&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# The events to emit is the second element of the tuple,&lt;/span&gt;
    &lt;span class="c1"&gt;# the third being the state.&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:noreply&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;demand&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class="highlighter-rouge"&gt;B&lt;/code&gt; is a producer-consumer. This means it does not explicitly handle the demand because the demand is always forwarded to its producers. Once &lt;code class="highlighter-rouge"&gt;A&lt;/code&gt; receives the demand from &lt;code class="highlighter-rouge"&gt;B&lt;/code&gt;, it will send events to &lt;code class="highlighter-rouge"&gt;B&lt;/code&gt; which will be transformed by &lt;code class="highlighter-rouge"&gt;B&lt;/code&gt; as desired and then sent to &lt;code class="highlighter-rouge"&gt;C&lt;/code&gt;. In our case, B will receive events and multiply them by a number given on initialization and stored as the state:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;alias&lt;/span&gt; &lt;span class="no"&gt;Experimental&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;GenStage&lt;/span&gt;

&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;B&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="no"&gt;GenStage&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:producer_consumer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;handle_events&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:noreply&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class="highlighter-rouge"&gt;C&lt;/code&gt; is the consumer which will finally receive those events and print them every second to the terminal:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;alias&lt;/span&gt; &lt;span class="no"&gt;Experimental&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;GenStage&lt;/span&gt;

&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;C&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="no"&gt;GenStage&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sleeping_time&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:consumer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sleeping_time&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;handle_events&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sleeping_time&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="c1"&gt;# Print events to terminal.&lt;/span&gt;
    &lt;span class="no"&gt;IO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inspect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Sleep the configured time.&lt;/span&gt;
    &lt;span class="no"&gt;Process&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sleeping_time&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# We are a consumer, so we never emit events.&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:noreply&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="n"&gt;sleeping_time&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;With the stages defined, we can start and connect them:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_link&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c1"&gt;# starting from zero&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_link&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c1"&gt;# multiply by 2&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_link&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# sleep for a second&lt;/span&gt;

&lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sync_subscribe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;to:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sync_subscribe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;to:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Sleep so we see events printed.&lt;/span&gt;
&lt;span class="no"&gt;Process&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:infinity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As soon as we subscribe the stages, we should see items being printed to the terminal. Notice that, even though we have introduced a sleep command to the consumer, the producers will never overflow the consumer with data. That’s because the communication between stages is demand-driven. The producer can only send items to consumers after the consumers have sent demand upstream. The producer must never send more items than the consumer has specified.&lt;/p&gt;

&lt;p&gt;One consequence of this design decision is that parallelizing stateless stages like the consumer above is really straightforward:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_link&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;# starting from zero&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_link&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;# multiply by 2&lt;/span&gt;

&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_link&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# sleep for a second&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_link&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# sleep for a second&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_link&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# sleep for a second&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c4&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_link&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# sleep for a second&lt;/span&gt;

&lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sync_subscribe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;to:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sync_subscribe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;to:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sync_subscribe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;to:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sync_subscribe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;to:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sync_subscribe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;to:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Sleep so we see events printed.&lt;/span&gt;
&lt;span class="no"&gt;Process&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:infinity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;By simply starting multiple consumers, the stage &lt;code class="highlighter-rouge"&gt;B&lt;/code&gt; will now receive demand from multiple stages and dispatch events to those stages which are now running concurrently, always picking the stage that is able to process more items. We can also leverage concurrency from the opposite direction: if the producer is the slow stage in a pipeline, you can start multiple producers and have each consumer subscribe to them.&lt;/p&gt;

&lt;p&gt;In order to know which consumer should receive a particular event, producer stages depend on a behaviour called &lt;a href="https://hexdocs.pm/gen_stage/Experimental.GenStage.Dispatcher.html"&gt;&lt;code class="highlighter-rouge"&gt;GenStage.Dispatcher&lt;/code&gt;&lt;/a&gt;. The default dispatcher is the &lt;code class="highlighter-rouge"&gt;GenStage.DemandDispatcher&lt;/code&gt; we have briefly described above: it will collect the demand from different consumers and dispatch to the one with highest demand. This means if one consumer is slow, maybe because we increased its sleeping time to 10 seconds, it will receive less items.&lt;/p&gt;

&lt;h3 id="genstage-for-data-ingestion"&gt;GenStage for data-ingestion&lt;/h3&gt;

&lt;p&gt;One of the use cases for GenStage is to consume data from third-party systems. The demand system with back-pressure guarantees we won’t import more data than we can effectively handle. The demand dispatcher allows us to easily leverage concurrency when processing the data by simply adding more consumers.&lt;/p&gt;

&lt;p&gt;During the Elixir London Meetup, I have live-coded a short example that shows how to use &lt;code class="highlighter-rouge"&gt;GenStage&lt;/code&gt; to concurrently process data stored in a PostgreSQL database as a queue:&lt;/p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/aZuY5-2lwW4" frameborder="0" allowfullscreen=""&gt;&lt;/iframe&gt;

&lt;h3 id="genstage-for-event-dispatching"&gt;GenStage for event dispatching&lt;/h3&gt;

&lt;p&gt;Another scenario where GenStage can be useful today is to replace cases where developers would have used &lt;a href="https://hexdocs.pm/elixir/GenEvent.html"&gt;GenEvent&lt;/a&gt; in the past. For those unfamiliar with GenEvent, it is a behaviour where events are sent to an “event manager” which then proceeds to invoke “event handlers” for each event. GenEvent, however, has one big flaw: the event manager and all event handlers run in the same process. This means GenEvent handlers cannot easily leverage concurrency without forcing developers to implement those mechanisms themselves. Furthermore, GenEvent handlers have very awkward error semantics. Because event handlers are not separate processes, we cannot simply rely on supervisors restarting them.&lt;/p&gt;

&lt;p&gt;GenStage solves those problems by having a producer as the event manager. The producer itself should be configured to use &lt;a href="https://hexdocs.pm/gen_stage/Experimental.GenStage.BroadcastDispatcher.html"&gt;&lt;code class="highlighter-rouge"&gt;GenStage.BroadcastDispatcher&lt;/code&gt;&lt;/a&gt; as its dispatcher. The broadcast dispatcher will guarantee events are dispatched to all consumers in a way that does not exceed the demand of any of the consumers. This allows us to leverage concurrency and having the “event manager” as a producer gives us much more flexibility in terms of buffering and reacting to failures.&lt;/p&gt;

&lt;p&gt;Let’s see an example of building an event manager as a producer:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;alias&lt;/span&gt; &lt;span class="no"&gt;Experimental&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;GenStage&lt;/span&gt;

&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;EventManager&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="no"&gt;GenStage&lt;/span&gt;

  &lt;span class="nv"&gt;@doc&lt;/span&gt; &lt;span class="sd"&gt;"""
  Starts the manager.
  """&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;start_link&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_link&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;__MODULE__&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;name:&lt;/span&gt; &lt;span class="bp"&gt;__MODULE__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="nv"&gt;@doc&lt;/span&gt; &lt;span class="sd"&gt;"""
  Sends an event and returns only after the event is dispatched.
  """&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;sync_notify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;timeout&lt;/span&gt; &lt;span class="p"&gt;\\&lt;/span&gt; &lt;span class="m"&gt;5000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;__MODULE__&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:notify&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="c1"&gt;## Callbacks&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:producer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="ss"&gt;dispatcher:&lt;/span&gt; &lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;BroadcastDispatcher&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;handle_call&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:notify&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;demand&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;dispatch_events&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;demand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[])&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;handle_demand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;incoming_demand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;demand&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;dispatch_events&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;incoming_demand&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;demand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[])&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;dispatch_events&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;demand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="ow"&gt;when&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;demand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
         &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;:queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;dispatch_events&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;demand&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
      &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:noreply&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;demand&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;code class="highlighter-rouge"&gt;EventManager&lt;/code&gt; works as a buffer. If there is demand but not events to be sent, we store such demand. If there are events but no demand, we store such events in a queue. If a client tries to broadcast an event, the &lt;code class="highlighter-rouge"&gt;sync_notify&lt;/code&gt; call will block until the event is effectively broadcasted. The bulk of the logic is in the &lt;code class="highlighter-rouge"&gt;dispatch_events/3&lt;/code&gt; function that takes events from the queue while there is demand.&lt;/p&gt;

&lt;p&gt;By implementing the event manager as a producer, we can configure all sorts of behaviours that are simply not possible with &lt;code class="highlighter-rouge"&gt;GenEvent&lt;/code&gt;, such as how much data we want to queue (or for how long) and if events should be buffered or not when there are no consumers (via the &lt;code class="highlighter-rouge"&gt;handle_subscribe/4&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;handle_cancel/3&lt;/code&gt; callbacks).&lt;/p&gt;

&lt;p&gt;Implementing event handlers is as straightforward as writing any other consumer. We could in fact use the &lt;code class="highlighter-rouge"&gt;C&lt;/code&gt; consumer implemented earlier. However, given event managers are often defined before the handlers, it is recommended for handlers to subscribe to managers when they start:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;alias&lt;/span&gt; &lt;span class="no"&gt;Experimental&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;GenStage&lt;/span&gt;

&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;EventHandler&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="no"&gt;GenStage&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;start_link&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_link&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;__MODULE__&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="c1"&gt;# Callbacks&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="c1"&gt;# Starts a permanent subscription to the broadcaster&lt;/span&gt;
    &lt;span class="c1"&gt;# which will automatically start requesting items.&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:consumer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;subscribe_to:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;EventManager&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;handle_events&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="no"&gt;IO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inspect&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:noreply&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Such guarantees that, if a supervised &lt;code class="highlighter-rouge"&gt;EventHandler&lt;/code&gt; crashes, the supervisor will start a new event handler which will promptly subscribe to the same manager, solving the awkward error handling semantics we have seen with &lt;code class="highlighter-rouge"&gt;GenEvent&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="the-path-forward"&gt;The path forward&lt;/h2&gt;

&lt;p&gt;With the release of GenStage v0.3.0, we have reached an important milestone as &lt;code class="highlighter-rouge"&gt;GenStage&lt;/code&gt; can be used as both event managers and a way to exchange events between processes, often external data sources, with back-pressure.&lt;/p&gt;

&lt;p&gt;The v0.3.0 release also includes the &lt;a href="https://hexdocs.pm/gen_stage/Experimental.GenStage.html#stream/1"&gt;&lt;code class="highlighter-rouge"&gt;GenStage.stream&lt;/code&gt;&lt;/a&gt; function, which allows us to consume data from a GenStage as a stream, and &lt;a href="https://hexdocs.pm/gen_stage/Experimental.GenStage.html#from_enumerable/2"&gt;&lt;code class="highlighter-rouge"&gt;GenStage.from_enumerable&lt;/code&gt;&lt;/a&gt; which allows us to use an enumerable or a stream, like &lt;code class="highlighter-rouge"&gt;File.stream!&lt;/code&gt;, as a producer. Closing the gap between stages and streams.&lt;/p&gt;

&lt;p&gt;However, we are far from done!&lt;/p&gt;

&lt;p&gt;First of all, now is the moment for the community to step in and try GenStage out. If you have used GenEvent in the past, can it be replaced by a GenStage? Similarly, if you were planning to implement an event handling system, give GenStage a try.&lt;/p&gt;

&lt;p&gt;Developers who maintain libraries that integrate with external data sources, be it a RabbitMQ, Redis or Apacha Kafka, can explore GenStage as an abstraction for consuming data from those sources. Library developers must implement producers and leave it up for their users to configure the consumer stages.&lt;/p&gt;

&lt;p&gt;Once we get enough feedback, &lt;code class="highlighter-rouge"&gt;GenStage&lt;/code&gt; will be included in some shape as part of the standard library. The goal is to introduce &lt;code class="highlighter-rouge"&gt;GenStage&lt;/code&gt; and phase &lt;code class="highlighter-rouge"&gt;GenEvent&lt;/code&gt; out in the long term.&lt;/p&gt;

&lt;p&gt;We, on the Elixir team, have just got started too. The next milestone for GenStage is to revisit the original problem and provide developers a clear path to take their collection processing code from eager, to lazy, to concurrent (and then distributed).&lt;/p&gt;

&lt;p&gt;As seen earlier, today we allow developers to transform eager code into lazy by introducing streams.&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;File&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stream!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;path/to/some/file"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flat_map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="no"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt; "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(%{},&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="no"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;While the above is helpful when working with large or infinite collections, it still does not leverage concurrency. To address that, we are currently exploring a solution named &lt;a href="https://hexdocs.pm/gen_stage/Experimental.Flow.html"&gt;&lt;code class="highlighter-rouge"&gt;GenStage.Flow&lt;/code&gt;&lt;/a&gt;, that allows us to express our computations similarly to streams, except they will run across multiple stages instead of a single process:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;alias&lt;/span&gt; &lt;span class="no"&gt;Experimental&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Flow&lt;/span&gt;
&lt;span class="no"&gt;File&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stream!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;path/to/some/file"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Flow&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_enumerable&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Flow&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flat_map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;for&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="no"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt; "&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Flow&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce_by_key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And the highly optimized version:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;alias&lt;/span&gt; &lt;span class="no"&gt;Experimental&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;GenStage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Flow&lt;/span&gt;

&lt;span class="c1"&gt;# Let's compile common patterns for performance&lt;/span&gt;
&lt;span class="n"&gt;empty_space&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;:binary&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile_pattern&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt; "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# NEW!&lt;/span&gt;

&lt;span class="no"&gt;File&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stream!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;path/to/some/file"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;read_ahead:&lt;/span&gt; &lt;span class="m"&gt;100_000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# NEW!&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Flow&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_enumerable&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Flow&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flat_map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;for&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="no"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;empty_space&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Flow&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;partition_with&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;storage:&lt;/span&gt; &lt;span class="ss"&gt;:ets&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# NEW!&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Flow&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce_by_key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Flow will look at the computations we want to perform and start a series of stages to execute our code while keeping the amount of data being transfered between processes to a minimum. If you are interested in &lt;code class="highlighter-rouge"&gt;GenStage.Flow&lt;/code&gt; and how the computations above are spread across multiple stages, &lt;a href="https://hexdocs.pm/gen_stage/Experimental.Flow.html"&gt;we have written some documentation based on the prototypes we have built so far&lt;/a&gt;. The code itself is coming in future GenStage releases. We will also have to consider how the &lt;code class="highlighter-rouge"&gt;GenStage.Flow&lt;/code&gt; API mirrors the functions in &lt;code class="highlighter-rouge"&gt;Enum&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Stream&lt;/code&gt; to make the path from eager to concurrent clearer.&lt;/p&gt;

&lt;p&gt;For the word counting problem with a fixed data, early experiments show a linear increase in performance with a fixed overhead of 20%. In other words, a dataset that takes 60s with a single core, takes 36s on a machine with 2 cores and 18s in one with 4 cores. All of those gains by simply moving your computations from streams to Flow. We plan to benchmark on machines with over 40 cores soon.&lt;/p&gt;

&lt;p&gt;We are very excited with the possibilities GenStage brings to developers and all new paths it allows us to explore and research. So give it a try and let us know! &lt;a href="http://www.elixirconf.com/"&gt;GenStage, Flows, and more will also be the topic of my keynote at ElixirConf 2016&lt;/a&gt; and we hope to see you there.&lt;/p&gt;

&lt;p&gt;Finally, we want to thank the &lt;a href="http://reactive-streams.io"&gt;akka-streams and reactive-streams projects&lt;/a&gt; which provided us guidance in implementing the demand-driven exchange between stages as well as the &lt;a href="http://spark.apache.org/"&gt;Apache Spark&lt;/a&gt; and &lt;a href="http://beam.incubator.apache.org/"&gt;Apache Beam&lt;/a&gt; initiatives that inspire the work behind &lt;code class="highlighter-rouge"&gt;GenStage.Flow&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v1.3 released</title>
    <link href="http://elixir-lang.org/blog/2016/06/21/elixir-v1-3-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2016-06-21T00:00:00+00:00</updated>
    <id>/blog/2016/06/21/elixir-v1-3-0-released</id>
    <content type="html">&lt;p&gt;Elixir v1.3 brings many improvements to the language, the compiler and its tooling, specially Mix (Elixir’s build tool) and ExUnit (Elixir’s test framework). The most notable additions are the new Calendar types, the new cross-reference checker in Mix, and the assertion diffing in ExUnit. We will explore all of them and a couple more enhancements below.&lt;/p&gt;

&lt;p&gt;With this release, we also welcome &lt;a href="http://github.com/whatyouhide"&gt;Andrea Leopardi&lt;/a&gt; to Elixir Core Team. He has contributed greatly to this release and maintains important packages in the community, like &lt;a href="https://github.com/elixir-lang/gettext"&gt;Gettext&lt;/a&gt; and &lt;a href="https://github.com/whatyouhide/redix"&gt;Redix&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="language-improvements"&gt;Language improvements&lt;/h2&gt;

&lt;p&gt;The language has been improved semantically and includes new types and APIs. Let’s see the three major features.&lt;/p&gt;

&lt;h3 id="deprecation-of-imperative-assignment"&gt;Deprecation of imperative assignment&lt;/h3&gt;

&lt;p&gt;Elixir will now warn if constructs like &lt;code class="highlighter-rouge"&gt;if&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;case&lt;/code&gt; and friends assign to a variable that is accessed in an outer scope. As an example, imagine a function called &lt;code class="highlighter-rouge"&gt;format&lt;/code&gt; that receives a message and some options and it must return a path alongside the message:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:file&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:line&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="n"&gt;relative&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;relative_to_cwd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;message&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Exception&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format_file_line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;relative&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt; "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;
      &lt;span class="n"&gt;relative&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;code class="highlighter-rouge"&gt;if&lt;/code&gt; block above is implicitly changing the value in &lt;code class="highlighter-rouge"&gt;message&lt;/code&gt;. Now imagine we want to move the &lt;code class="highlighter-rouge"&gt;if&lt;/code&gt; block to its own function to clean up the implementation:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;with_file_and_line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;with_file_and_line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:file&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:line&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;relative&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;relative_to_cwd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;message&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Exception&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format_file_line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;relative&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt; "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;
    &lt;span class="n"&gt;relative&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The refactored version is broken because the &lt;code class="highlighter-rouge"&gt;if&lt;/code&gt; block was actually returning two values, the relative path &lt;em&gt;and&lt;/em&gt; the new message. Elixir v1.3 will warn on such cases, forcing both variables to be explicitly returned from &lt;code class="highlighter-rouge"&gt;if&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;case&lt;/code&gt; and other constructs. Furthermore, this change gives us the opportunity to unify the language scoping rules in future releases.&lt;/p&gt;

&lt;h3 id="calendar-types-and-sigils"&gt;Calendar types and sigils&lt;/h3&gt;

&lt;p&gt;Elixir v1.3 introduces the &lt;code class="highlighter-rouge"&gt;Calendar&lt;/code&gt; module as well as 4 new calendar types:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;Date&lt;/code&gt; - used to store dates (year, month, day) in a given calendar&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;Time&lt;/code&gt; - used to store time (hour, minute, second, microseconds)&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;NaiveDateTime&lt;/code&gt; - used to store datetimes without a timezone (year, month, day, hour, minute, second, microseconds) in a given calendar. It is called naïve because without a timezone, the datetime may not actually exist. For example, when there are daylight savings changes, a whole hour may not exist (when the clock moves forward) or a particular instant may happen twice (when the clock moves backwards)&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;DateTime&lt;/code&gt; - used to store datetimes with timezone (year, month, day, hour, minute, second, microsecond and time zone, with abbreviation, UTC and standard offset)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The aim of the current implementation of the Calendar modules and its types is to provide a base for interoperatibility in the ecosystem instead of full-featured datetime API. This release includes basic functionality for building new types and converting them from and back strings.&lt;/p&gt;

&lt;p&gt;Elixir v1.3 also introduces 3 new sigils related to the types above:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;~D[2016-05-29]&lt;/code&gt; - builds a new date&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;~T[08:00:00]&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;~T[08:00:00.285]&lt;/code&gt; - builds a new time (with different precisions)&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;~N[2016-05-29 08:00:00]&lt;/code&gt; - builds a naive date time&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="access-selectors"&gt;Access selectors&lt;/h3&gt;

&lt;p&gt;This release introduces new accessors to make it simpler for developers to traverse nested data structures, traversing and updating data in different ways.  For instance, given a user with a list of languages, here is how to deeply traverse the map and convert all language names to uppercase:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; user = %{name: "john",
...&amp;gt;          languages: [%{name: "elixir", type: :functional},
...&amp;gt;                      %{name: "c", type: :procedural}]}
iex&amp;gt; update_in user, [:languages, Access.all(), :name], &amp;amp;String.upcase/1
%{name: "john",
  languages: [%{name: "ELIXIR", type: :functional},
              %{name: "C", type: :procedural}]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see the new accessors in the &lt;code class="highlighter-rouge"&gt;Access&lt;/code&gt; module.&lt;/p&gt;

&lt;h2 id="mix"&gt;Mix&lt;/h2&gt;

&lt;p&gt;Mix includes new tasks to improve your everyday workflow. Some of those tasks relies on many compiler improvements to know more about your code, providing static analysis to find possible bugs in your code and faster compilation cycles.&lt;/p&gt;

&lt;h3 id="compiling-n-files"&gt;Compiling n files&lt;/h3&gt;

&lt;p&gt;Mix no longer announces every file it compiles. Instead it outputs how many files there is to compile per compilers. Here is the output for a project like &lt;a href="https://github.com/elixir-lang/gettext"&gt;&lt;code class="highlighter-rouge"&gt;gettext&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;Compiling 1 file (.yrl)
Compiling 1 file (.erl)
Compiling 19 files (.ex)
Generated gettext app
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In case a file is taking too long to compile, Mix will announce such, for example:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;Compiling lib/gettext.ex (it's taking more than 10s)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The goal of these changes is to put an increased focus on the “warnings” emitted by the compiler.&lt;/p&gt;

&lt;p&gt;In any case, the previous behaviour can be brought back with the &lt;code class="highlighter-rouge"&gt;--verbose&lt;/code&gt; flag and the compilation threshold for files that are taking long can be set via the &lt;code class="highlighter-rouge"&gt;--long-compilation-threshold&lt;/code&gt; option.&lt;/p&gt;

&lt;h3 id="mix-xref"&gt;mix xref&lt;/h3&gt;

&lt;p&gt;Speaking about warnings, Mix v1.3 includes a new task called &lt;code class="highlighter-rouge"&gt;xref&lt;/code&gt; that performs cross reference checks in your code. One of such checks is the ability to find calls to modules and functions that do not exist. For example, if in your library code you call &lt;code class="highlighter-rouge"&gt;ThisModuleDoesNotExist.foo(1, 2, 3)&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;mix xref unreachable&lt;/code&gt; will be able to find such code and let you know about it.&lt;/p&gt;

&lt;p&gt;Since such checks can discover possible bugs in your codebase, a new compiler called &lt;code class="highlighter-rouge"&gt;xref&lt;/code&gt; has been added to &lt;code class="highlighter-rouge"&gt;Mix.compilers/0&lt;/code&gt;, so it runs by default every time you compile your code. &lt;a href="https://pragtob.wordpress.com/2016/06/02/elixir-1-3s-mix-xref-working-its-magic-in-a-real-world-example/"&gt;PragTob has written an article exploring how this new compiler has found bugs in existing projects&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We have included other modes in &lt;code class="highlighter-rouge"&gt;xref&lt;/code&gt;, such as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class="highlighter-rouge"&gt;mix xref callers Foo&lt;/code&gt; - used to find all places in your code that calls a function from the module &lt;code class="highlighter-rouge"&gt;Foo&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class="highlighter-rouge"&gt;mix xref graph&lt;/code&gt; - generates a graph with dependencies between source files&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can find documentation for all modes by running &lt;code class="highlighter-rouge"&gt;mix help xref&lt;/code&gt;. We hope tools and text editors can leverage such features to provide useful functionality for their users, helping developers understand code complexity and finding bugs early on.&lt;/p&gt;

&lt;h3 id="better-dependency-tracking"&gt;Better dependency tracking&lt;/h3&gt;

&lt;p&gt;Besides &lt;code class="highlighter-rouge"&gt;xref&lt;/code&gt;, Elixir v1.3 provides better module tracking generally. For example, in previous versions, if you changed a &lt;code class="highlighter-rouge"&gt;:path&lt;/code&gt; dependency, Elixir would always fully recompile the current project. In this release, we have improved the tracking algorithms such that, if you change a &lt;code class="highlighter-rouge"&gt;:path&lt;/code&gt; dependency, only the files that depend on such dependency are recompiled.&lt;/p&gt;

&lt;p&gt;Such improvements do not only make compilation faster but they also make working with umbrella applications much more productive. Previously, changing a sibling application triggered a full project recompilation, now Elixir can track between sibling applications and recompile only what is needed.&lt;/p&gt;

&lt;h3 id="mix-apptree-and-depstree"&gt;mix app.tree and deps.tree&lt;/h3&gt;

&lt;p&gt;Mix also includes both &lt;code class="highlighter-rouge"&gt;mix app.tree&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;mix deps.tree&lt;/code&gt;. The first will list all applications your current project needs to start in order to boot (i.e. the ones listed in &lt;code class="highlighter-rouge"&gt;application/0&lt;/code&gt; in your &lt;code class="highlighter-rouge"&gt;mix.exs&lt;/code&gt;) while the second will lists all of your dependencies and so on recursively.&lt;/p&gt;

&lt;p&gt;Here is a quick example from &lt;a href="https://github.com/elixir-lang/plug"&gt;Plug&lt;/a&gt;:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;mix&lt;/span&gt; &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tree&lt;/span&gt;
&lt;span class="n"&gt;plug&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;elixir&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;crypto&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;logger&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;   &lt;span class="err"&gt;└──&lt;/span&gt; &lt;span class="n"&gt;elixir&lt;/span&gt;
&lt;span class="err"&gt;└──&lt;/span&gt; &lt;span class="n"&gt;mime&lt;/span&gt;
    &lt;span class="err"&gt;└──&lt;/span&gt; &lt;span class="n"&gt;elixir&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;code class="highlighter-rouge"&gt;--format dot&lt;/code&gt; option can also be given to generate graph files to be opened by &lt;a href="http://www.graphviz.org"&gt;GraphViz&lt;/a&gt;. For example, here is the output of running &lt;code class="highlighter-rouge"&gt;mix deps.tree --format dot --only prod&lt;/code&gt; in the &lt;a href="http://phoenixframework.org"&gt;Phoenix web framework&lt;/a&gt;:&lt;/p&gt;

&lt;p style="text-align: center"&gt;
  &lt;img src="/images/contents/deps-tree-phoenix.svg" alt="mix deps.tree for Phoenix in production" /&gt;
&lt;/p&gt;

&lt;h3 id="mix-escriptinstall"&gt;mix escript.install&lt;/h3&gt;

&lt;p&gt;Mix also includes &lt;code class="highlighter-rouge"&gt;mix escript.install&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;mix escript.uninstall&lt;/code&gt; tasks for managing escripts. The tasks was designed in a way to mimic the existing &lt;code class="highlighter-rouge"&gt;mix archive&lt;/code&gt; functionality except that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Archives must be used sparingly because every new archive installed affects Mix performance, as every new archive is loaded when Mix boots. Escripts solve this by being managed apart from your Elixir/Mix installed&lt;/li&gt;
  &lt;li&gt;Archives depends on the current Elixir version. Therefore, updating your Elixir version may break an archive. Fortunately, escripts include Elixir inside themselves, and therefore do not depend on your Elixir system version&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Escripts will be installed at &lt;code class="highlighter-rouge"&gt;~/.mix/escripts&lt;/code&gt; which must be added to your &lt;a href="https://en.wikipedia.org/wiki/PATH_(variable)"&gt;&lt;code class="highlighter-rouge"&gt;PATH&lt;/code&gt; environment variable&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id="option-parser-integration"&gt;Option parser integration&lt;/h3&gt;

&lt;p&gt;Elixir v1.3 includes improvements to the option parser, including &lt;code class="highlighter-rouge"&gt;OptionParser.parse!/2&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;OptionParser.parse_head!/2&lt;/code&gt; functions that will raise in case of invalid or unknown switches. Mix builds on top of this functionality to provide automatic error reporting solving a common complaint where invalid options were not reported by Mix tasks.&lt;/p&gt;

&lt;p&gt;For example, invoking &lt;code class="highlighter-rouge"&gt;mix test --unknown&lt;/code&gt; in earlier Elixir versions would silently discard the &lt;code class="highlighter-rouge"&gt;--unknown&lt;/code&gt; option. Now &lt;code class="highlighter-rouge"&gt;mix test&lt;/code&gt; correctly reports such errors:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;$ mix test --unknown
** (Mix) Could not invoke task "test": 1 error found!
--unknown : Unknown option
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Note not all tasks have been updated to use strict option parsing. Some tasks, like &lt;code class="highlighter-rouge"&gt;mix compile&lt;/code&gt;, are actually a front-end to many other tasks, and as such, it cannot effectively assert which options are valid.&lt;/p&gt;

&lt;h2 id="exunit"&gt;ExUnit&lt;/h2&gt;

&lt;p&gt;ExUnit packs many improvements on the tooling side, better integration with external tools, as well as mechanisms to improve the readability of your tests.&lt;/p&gt;

&lt;h3 id="mix-test---stale"&gt;mix test --stale&lt;/h3&gt;

&lt;p&gt;ExUnit builds on top of &lt;code class="highlighter-rouge"&gt;mix xref&lt;/code&gt; to provide the &lt;code class="highlighter-rouge"&gt;mix test --stale&lt;/code&gt; functionality. When the &lt;code class="highlighter-rouge"&gt;--stale&lt;/code&gt; flag is given, &lt;code class="highlighter-rouge"&gt;mix&lt;/code&gt; will only run the tests that may have changed since the last time you ran &lt;code class="highlighter-rouge"&gt;mix test --stale&lt;/code&gt;. For example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If you saved a test file on disk, Mix will run that file and ignore the ones that have not changed&lt;/li&gt;
  &lt;li&gt;If you changed a library file, for example, &lt;code class="highlighter-rouge"&gt;lib/foo.ex&lt;/code&gt; that defines &lt;code class="highlighter-rouge"&gt;Foo&lt;/code&gt;, any test that invokes a function in &lt;code class="highlighter-rouge"&gt;Foo&lt;/code&gt; directly or indirectly will also run&lt;/li&gt;
  &lt;li&gt;If you modify your &lt;code class="highlighter-rouge"&gt;mix.exs&lt;/code&gt; or your &lt;code class="highlighter-rouge"&gt;test/test_helper.exs&lt;/code&gt;, Mix will run the whole test suite&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This feature provides a great workflow for developers, allowing them to effortlessly focus on parts of the codebase when developing new features.&lt;/p&gt;

&lt;h3 id="diffing"&gt;Diffing&lt;/h3&gt;

&lt;p&gt;ExUnit will now include diff-ing output every time a developer asserts &lt;code class="highlighter-rouge"&gt;assert left == right&lt;/code&gt; in their tests. For example, the assertion:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;assert&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;fox jumps over the lazy dog"&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt;
       &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;brown fox jumps over the dog"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;will fail with&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/contents/exunit-diff.png" alt="ExUnit diff" /&gt;&lt;/p&gt;

&lt;p&gt;such that “lazy” in “lhs” will be shown in red to denote it has been removed from “rhs” while “brown” in “rhs” will be shown in green to denote it has been added to the “rhs”.&lt;/p&gt;

&lt;p&gt;When working with large or nested data structures, the diffing algorithm makes it fast and convenient to spot the actual differences in the asserted values.&lt;/p&gt;

&lt;h3 id="test-types"&gt;Test types&lt;/h3&gt;

&lt;p&gt;ExUnit v1.3 includes the ability to register different test types. This means libraries like QuickCheck can now provide functionality such as:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;StringTest&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="no"&gt;ExUnit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Case&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;async:&lt;/span&gt; &lt;span class="no"&gt;true&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="no"&gt;PropertyTestingLibrary&lt;/span&gt;

  &lt;span class="n"&gt;property&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;starts_with?"&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;forall&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;utf8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;utf8&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="no"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;starts_with?&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;At the end of the run, ExUnit will also report it as a property, including both the amount of tests and properties:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;1 property, 10 tests, 0 failures
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id="named-setups-and-describes"&gt;Named setups and describes&lt;/h3&gt;

&lt;p&gt;Finally, ExUnit v1.3 includes the ability to organize tests together in describe blocks:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;StringTest&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="no"&gt;ExUnit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Case&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;async:&lt;/span&gt; &lt;span class="no"&gt;true&lt;/span&gt;

  &lt;span class="n"&gt;describe&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;String.capitalize/2"&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;uppercases the first grapheme"&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="n"&gt;assert&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;T"&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capitalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;test"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;lowercases the remaining graphemes"&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="n"&gt;assert&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;Test"&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capitalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;TEST"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Every test inside a describe block will be tagged with the describe block name. This allows developers to run tests that belong to particular blocks, be them in the same file or across many files:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;$ mix test --only describe:"String.capitalize/2"
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Note describe blocks cannot be nested. Instead of relying on hierarchy for composition, we want developers to build on top of named setups. For example:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;UserManagementTest&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="no"&gt;ExUnit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Case&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;async:&lt;/span&gt; &lt;span class="no"&gt;true&lt;/span&gt;

  &lt;span class="n"&gt;describe&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;when user is logged in and is an admin"&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;setup&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:log_user_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:set_type_to_admin&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="n"&gt;describe&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;when user is logged in and is a manager"&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;setup&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:log_user_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:set_type_to_manager&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;log_user_in&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="c1"&gt;# ...&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;By restricting hierarchies in favor of named setups, it is straight-forward for the developer to glance at each describe block and know exactly the setup steps involved.&lt;/p&gt;

&lt;h2 id="summing-up"&gt;Summing up&lt;/h2&gt;

&lt;p&gt;The full list of changes is available in our &lt;a href="https://github.com/elixir-lang/elixir/releases/tag/v1.3.0"&gt;release notes&lt;/a&gt;. Don’t forget to check &lt;a href="/install.html"&gt;the Install section&lt;/a&gt; to get Elixir installed and our &lt;a href="http://elixir-lang.org/getting-started/introduction.html"&gt;Getting Started guide&lt;/a&gt; to learn more.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v1.2 released</title>
    <link href="http://elixir-lang.org/blog/2016/01/03/elixir-v1-2-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2016-01-03T00:00:00+00:00</updated>
    <id>/blog/2016/01/03/elixir-v1-2-0-released</id>
    <content type="html">&lt;p&gt;v1.2 brings enhancements, bug fixes, performance improvements and more into Elixir. Elixir v1.2 relies on many features in Erlang 18, requiring at least Erlang 18+. Upgrading to Erlang 18 is therefore necessary before upgrading Elixir.&lt;/p&gt;

&lt;p&gt;To celebrate this release and the new year, we have also reviewed both the &lt;a href="http://elixir-lang.org/getting-started/introduction.html"&gt;Getting Started&lt;/a&gt; and &lt;a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html"&gt;Mix &amp;amp; OTP&lt;/a&gt; guides, bringing it up to date and exploring new functionalities added since Elixir v1.0.&lt;/p&gt;

&lt;h2 id="erlang-18-support"&gt;Erlang 18 support&lt;/h2&gt;

&lt;p&gt;We have brought many features specific to Erlang 18. Here are the highlights:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Maps can now scale from dozens to millions of keys. Therefore, usage of the modules &lt;code class="highlighter-rouge"&gt;Dict&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;HashDict&lt;/code&gt; is now discouraged and will be deprecated in future releases, instead use &lt;code class="highlighter-rouge"&gt;Map&lt;/code&gt;. Similarly, &lt;code class="highlighter-rouge"&gt;Set&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;HashSet&lt;/code&gt; will be deprecated in favor of &lt;code class="highlighter-rouge"&gt;MapSet&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Compilation times are ~15% faster on average due to improvements in both the Elixir and Erlang compilers and by using maps more extensively in the compilation stack&lt;/li&gt;
  &lt;li&gt;Dialyzer now emits less false negative warnings thanks to new annotations available in the Erlang compiler&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="language-improvements"&gt;Language improvements&lt;/h2&gt;

&lt;p&gt;This release includes many notable language improvements.&lt;/p&gt;

&lt;p&gt;The first of them was the addition of multi aliases/imports/require. Often developers would write:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;alias&lt;/span&gt; &lt;span class="no"&gt;MyApp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Foo&lt;/span&gt;
&lt;span class="n"&gt;alias&lt;/span&gt; &lt;span class="no"&gt;MyApp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Bar&lt;/span&gt;
&lt;span class="n"&gt;alias&lt;/span&gt; &lt;span class="no"&gt;MyApp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Baz&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now it can be written in one line by using the new multi syntax:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;alias&lt;/span&gt; &lt;span class="no"&gt;MyApp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="no"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;Bar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;Baz&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We have also added support for variables in map keys. Now you can write:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; key = :hello
iex&amp;gt; value = "world"
iex&amp;gt; %{key =&amp;gt; value}
%{:hello =&amp;gt; "world"}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Furthermore, variables can also be used on pattern matching along-side the pin operator:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;iex&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;:hello&lt;/span&gt;
&lt;span class="n"&gt;iex&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;%{&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;%{&lt;/span&gt;&lt;span class="ss"&gt;:hello&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;another world"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;iex&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;
&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;another world"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Finally, Elixir v1.2 introduces the &lt;code class="highlighter-rouge"&gt;with&lt;/code&gt; special form that allows developers to match on multiple expressions concisely. Previously, one would write&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="no"&gt;File&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;my_file.ex"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="no"&gt;Code&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eval_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_binding&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="n"&gt;error&lt;/span&gt;
  &lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;
    &lt;span class="n"&gt;error&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;such can now be rewritten as&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="no"&gt;File&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;my_file.ex"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
     &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;binding&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="no"&gt;Code&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eval_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
     &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ok&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class="highlighter-rouge"&gt;with&lt;/code&gt; will match each left side of &lt;code class="highlighter-rouge"&gt;&amp;lt;-&lt;/code&gt; against the right side, executing expressions until one of those match fails or until the &lt;code class="highlighter-rouge"&gt;do: expression&lt;/code&gt; is performed. In case a match fails, the non-matching result is returned.&lt;/p&gt;

&lt;p&gt;These improvements aim to make the language more consistent and expressive.&lt;/p&gt;

&lt;h2 id="getting-started-experience"&gt;Getting started experience&lt;/h2&gt;

&lt;p&gt;We have also improved both the parser and compiler to be more aware of language constructs, emitting warnings on common pitfalls like when piping to expressions without parentheses or when defining unsafe variables. Such improvements will point developers to the more idiomatic way of writing Elixir code early on.&lt;/p&gt;

&lt;p&gt;Elixir v1.2 also introduces the &lt;code class="highlighter-rouge"&gt;i/1&lt;/code&gt; helper in IEx, which allows developers to retrieve information about any data type. This will help newcomers explore the language values while providing experienced developers with crucial information about the value they are introspecting. For example, giving a PID to &lt;code class="highlighter-rouge"&gt;i/1&lt;/code&gt; will show if it has a registered name, linked processes and more. Giving it a module, like &lt;code class="highlighter-rouge"&gt;i(String)&lt;/code&gt;, shows compile-time information and others.&lt;/p&gt;

&lt;p&gt;All of those improvements tie nicely with our updates to the Getting Started guide, ensuring learning Elixir is more fun and efficient than ever before.&lt;/p&gt;

&lt;h2 id="workflow-improvements"&gt;Workflow improvements&lt;/h2&gt;

&lt;p&gt;One of Elixir goals is to build upon the abstractions provided by Erlang/OTP and make them more productive by focusing on the tooling aspect.&lt;/p&gt;

&lt;p&gt;One of such efforts resulted in “Umbrella Projects”, which allows developers to build multiple applications side-by-side, but still run and test them in isolation when desired. Because each application contains its own configuration, supervision tree and initialization cycle, this gives developers the proper mechanisms to break monolithic applications apart without introducing the complexity of managing multiple, different repositories.&lt;/p&gt;

&lt;p&gt;Up to this release, umbrella applications shared mostly dependencies, which meant each application still had their own build directory and their own compilation cycle. Elixir v1.2 allows developers to also share both build and configuration files. This change allows teams to drastically reduce compilation times in umbrella projects by adding the following configuration to each umbrella app’s &lt;code class="highlighter-rouge"&gt;mix.exs&lt;/code&gt; file:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="ss"&gt;build_path:&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;../../_build"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="ss"&gt;config_path:&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;../../config/config.exs"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Umbrella applications generated with Elixir v1.2 will by default include this configuration. The downside of this approach is that applications are a bit less isolated, since configuration is now shared across all projects, although developers can revert back to the previous behaviour by simply removing the flags above.&lt;/p&gt;

&lt;p&gt;Finally, Mix will now consolidate protocols by default as we are now able to consolidate in parallel and cache the consolidation results, providing the best performance across all environments without affecting compilation times.&lt;/p&gt;

&lt;p&gt;These are great additions on top of the faster compilation times we have achieved when migrating to Erlang 18.&lt;/p&gt;

&lt;h2 id="rebar-3-support"&gt;Rebar 3 support&lt;/h2&gt;

&lt;p&gt;With Rebar 3 gaining more adoption in the Erlang community, Mix is now able to fetch and compile Rebar 3 dependencies. This feature is currently experimental and therefore opt-in: if you have a Rebar 3 dependency, you can ask Mix to use Rebar 3 to compile it by passing the &lt;code class="highlighter-rouge"&gt;manager: :rebar3&lt;/code&gt; option. Once configured, Mix will prompt you to install Rebar 3 if it is not yet available.&lt;/p&gt;

&lt;p&gt;The full list of changes is available in our &lt;a href="https://github.com/elixir-lang/elixir/releases/tag/v1.2.0"&gt;release notes&lt;/a&gt;. Don’t forget to check &lt;a href="/install.html"&gt;the Install section&lt;/a&gt; to get Elixir installed and our &lt;a href="http://elixir-lang.org/getting-started/introduction.html"&gt;Getting Started guide&lt;/a&gt; to learn more.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v1.1 released</title>
    <link href="http://elixir-lang.org/blog/2015/09/28/elixir-v1-1-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2015-09-28T00:00:00+00:00</updated>
    <id>/blog/2015/09/28/elixir-v1-1-0-released</id>
    <content type="html">&lt;p&gt;Elixir v1.1 has been released and it brings enhancements, bug fixes, performance improvements and more into Elixir.&lt;/p&gt;

&lt;p&gt;Elixir v1.1 supports both Erlang 17 and Erlang 18. This is, however, the last release supporting Erlang 17, so upgrading to Erlang 18 is advised. Elixir v1.2 will introduce features that are Erlang 18 only.&lt;/p&gt;

&lt;p&gt;On the standard library side, about 40 new functions have been added to Elixir public APIs. For example, &lt;a href="/docs/v1.1/elixir/Enum.html"&gt;&lt;code class="highlighter-rouge"&gt;Enum&lt;/code&gt;&lt;/a&gt; got &lt;a href="/docs/v1.1/elixir/Enum.html#dedup/1"&gt;&lt;code class="highlighter-rouge"&gt;dedup/1&lt;/code&gt;&lt;/a&gt;, &lt;a href="/docs/v1.1/elixir/Enum.html#random/1"&gt;&lt;code class="highlighter-rouge"&gt;random/1&lt;/code&gt;&lt;/a&gt;, and a couple more. The &lt;a href="/docs/v1.1/elixir/String.html"&gt;&lt;code class="highlighter-rouge"&gt;String&lt;/code&gt;&lt;/a&gt; module can now &lt;a href="/docs/v1.1/elixir/String.html#jaro_distance/2"&gt;calculate the distance between strings&lt;/a&gt;. We use this feature to provide suggestions whenever an unknown task name is given when using Mix. You can also &lt;a href="/docs/v1.1/elixir/Task.html#yield/2"&gt;yield to&lt;/a&gt; and &lt;a href="/docs/v1.1/elixir/Task.html#shutdown/2"&gt;shutdown&lt;/a&gt; tasks in the &lt;a href="/docs/v1.1/elixir/Task.html"&gt;&lt;code class="highlighter-rouge"&gt;Task&lt;/code&gt;&lt;/a&gt; module.&lt;/p&gt;

&lt;p&gt;The applications that ship with Elixir also has seen improvements and bug fixes. &lt;a href="/docs/v1.1/ex_unit/ExUnit.html"&gt;ExUnit&lt;/a&gt;, Elixir’s test framework, now has support for skipping tests via tags &lt;code class="highlighter-rouge"&gt;@tag :skip&lt;/code&gt;, as well as the ability to capture logs via &lt;code class="highlighter-rouge"&gt;@tag :capture_log&lt;/code&gt;, ensuring that all log messages during the tests are captured. Even better, in case of failures, all captured log messages are printed along-side the test error report.&lt;/p&gt;

&lt;p&gt;Mix ships with a &lt;a href="/docs/v1.1/mix/Mix.Tasks.Profile.Fprof.html"&gt;&lt;code class="highlighter-rouge"&gt;mix profile.fprof&lt;/code&gt;&lt;/a&gt;, useful for profiling your application code. The &lt;a href="/docs/v1.1/mix/Mix.Tasks.App.Start.html"&gt;&lt;code class="highlighter-rouge"&gt;mix app.start&lt;/code&gt;&lt;/a&gt; has also been publicly documented. Although you likely won’t invoke it directly through the command line, it is useful when writing your own tasks that require the current application to be up and running.&lt;/p&gt;

&lt;p&gt;Mix also provides faster re-compilation times. Every time you compile your Elixir code, Mix generates a graph of the dependencies between source files. For example, if &lt;code class="highlighter-rouge"&gt;a.ex&lt;/code&gt; depends on &lt;code class="highlighter-rouge"&gt;b.ex&lt;/code&gt;, every time &lt;code class="highlighter-rouge"&gt;b.ex&lt;/code&gt; changes, &lt;code class="highlighter-rouge"&gt;a.ex&lt;/code&gt; must be recompiled. Elixir v1.1 improves this tracking by separating compile-time dependencies from runtime ones, recompiling a file only if a compile-time dependency changed. In projects that have a main dispatch entity, like a web-app router, we have seen &lt;code class="highlighter-rouge"&gt;mix compile&lt;/code&gt; go from recompiling the whole project to one or two files per run.&lt;/p&gt;

&lt;p&gt;We have also seen great progress on areas that go beyond the source code. In particular, we have added a &lt;a href="https://github.com/elixir-lang/elixir/blob/v1.1/CODE_OF_CONDUCT.md"&gt;CODE_OF_CONDUCT.md&lt;/a&gt; to guarantee our community continues to grow into a safe and welcoming place for everyone.&lt;/p&gt;

&lt;p&gt;We have also released a new ExDoc version. It provides a &lt;a href="https://hexdocs.pm/elixir/1.1.0"&gt;beautiful, clean and readable way to navigate the Elixir documentation&lt;/a&gt; and it is available to any Elixir project. The latest version includes initial support for User Guides and we have more features and improvements coming on the way.&lt;/p&gt;

&lt;p&gt;The full list of changes is available in our &lt;a href="https://github.com/elixir-lang/elixir/releases/tag/v1.1.0"&gt;release notes&lt;/a&gt;. Don’t forget to check &lt;a href="/install.html"&gt;the Install section&lt;/a&gt; to get Elixir installed.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v1.0 released</title>
    <link href="http://elixir-lang.org/blog/2014/09/18/elixir-v1-0-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2014-09-18T00:00:00+00:00</updated>
    <id>/blog/2014/09/18/elixir-v1-0-0-released</id>
    <content type="html">&lt;p&gt;We are glad to announce Elixir v1.0 is finally out. It has been 8005 commits &lt;a href="https://github.com/elixir-lang/elixir/graphs/contributors?from=2011-01-12&amp;amp;to=2014-09-10&amp;amp;type=c"&gt;by 189 contributors&lt;/a&gt;, including the initial commit on &lt;a href="https://github.com/elixir-lang/elixir/commit/337c3f2d569a42ebd5fcab6fef18c5e012f9be5b"&gt;January 9th, 2011&lt;/a&gt;!&lt;/p&gt;

&lt;h2 id="whats-elixir"&gt;What’s Elixir?&lt;/h2&gt;

&lt;p&gt;Elixir is a dynamic, functional language designed for building scalable and maintainable applications.&lt;/p&gt;

&lt;p&gt;Elixir leverages the Erlang VM, known for running low-latency, distributed and fault-tolerant systems, while also being successfully used in web development and the embedded software domain.&lt;/p&gt;

&lt;h2 id="whats-new"&gt;What’s new?&lt;/h2&gt;

&lt;p&gt;This release is the consolidation of all the work done through the years. With v1.0, we have reached a stable milestone for the growth of software and projects written in Elixir.&lt;/p&gt;

&lt;p&gt;Elixir will follow &lt;a href="http://semver.org"&gt;semantic versioning&lt;/a&gt;, which means code written for Elixir v1.0 will continue to compile and run correctly for all versions under the v1 branch (e.g. v1.0.1, v1.1.0, v1.2.0).&lt;/p&gt;

&lt;p&gt;Elixir is composed of 6 applications, all under the same versioning constraints:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://hexdocs.pm/elixir/"&gt;Elixir&lt;/a&gt; - the Elixir compiler, runtime and the standard library&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://hexdocs.pm/eex/"&gt;EEx&lt;/a&gt; - Elixir’s templating library, useful for generating any kind of document dynamically&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://hexdocs.pm/ex_unit/"&gt;ExUnit&lt;/a&gt; - Elixir’s unit test library, with support for concurrent testing, custom formatters, filters and much more&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://hexdocs.pm/iex/"&gt;IEx&lt;/a&gt; - Elixir’s interactive shell with code reloading, auto-complete, and easy access to documentation, typespecs and more&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://hexdocs.pm/logger/"&gt;Logger&lt;/a&gt; - the latest addition to the group, Logger provides reliable logging and configurable backends (with syslog, file and many other backends provided by the community)&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://hexdocs.pm/mix/"&gt;Mix&lt;/a&gt; - Elixir’s build tool that generates, compiles and tests projects as well as manages your dependencies&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With v1.0, we are providing a stable platform for the community to leverage and extend, and we are extremely excited with the projects and possibilities that are ahead of us!&lt;/p&gt;

&lt;p&gt;We hope the &lt;a href="https://hex.pm"&gt;Hex package manager&lt;/a&gt; will be the home of many of those projects and remember the whole Erlang ecosystem is also available to Elixir developers.&lt;/p&gt;

&lt;h2 id="expectations"&gt;Expectations&lt;/h2&gt;

&lt;p&gt;We would like to elaborate on the expectations regarding Elixir v1.0. Although we expect that the vast majority of programs will remain compatible over time, it is impossible to guarantee that no future change will break any program.&lt;/p&gt;

&lt;p&gt;Under some unlikely circumstances, we may introduce changes that break existing code:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Security: a security issue in the implementation may arise whose resolution requires backwards incompatible changes. We reserve the right to address such security issues.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bugs: if an application has undesired behaviour, a program that depends on the buggy behaviour may break if the bug is fixed. We reserve the right to fix such bugs.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Compiler front-end: improvements may be done to the compiler, introducing new warnings for ambiguous modes and providing more detailed error messages. Those can lead to compilation errors (when running with &lt;code class="highlighter-rouge"&gt;--warning-as-errors&lt;/code&gt;) or tooling failures when asserting on specific error messages (although one should avoid such). We reserve the right to do such improvements.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Imports: new functions may be added to the Kernel module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using &lt;code class="highlighter-rouge"&gt;import Kernel, except: [...]&lt;/code&gt; with a list of all functions you don’t want imported from Kernel. We reserve the right to do such additions.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Elixir binaries are guaranteed to be backwards compatible within the same branch. Code compiled with v1.0 shall work with Elixir v1.0.1 runtime but code compiled with Elixir v1.0 should be recompiled to work with Elixir v1.1.0 onwards.&lt;/p&gt;

&lt;p&gt;These expectations also apply to future releases under the v1 branch, except for experimental features, which will be explicitly marked as such and not provide any compatibility guarantee until they are stabilized.&lt;/p&gt;

&lt;h2 id="learn-more"&gt;Learn more&lt;/h2&gt;

&lt;p&gt;You can get started with Elixir via our &lt;a href="/getting-started/introduction.html"&gt;Getting Started guide&lt;/a&gt;. There are quite some Elixir books out there too, now getting sent to the presses, quite a few can be found in the sidebar, which also includes screencasts and other resources.&lt;/p&gt;

&lt;p&gt;You can also learn more about Elixir by checking out &lt;a href="http://www.confreaks.com/events/elixirconf2014"&gt;the videos from ElixirConf 2014&lt;/a&gt;, the first (and so far the best) Elixir conference ever! You can learn more about &lt;a href="http://www.confreaks.com/videos/4134-elixirconf2014-keynote-elixir"&gt;the language history&lt;/a&gt;, &lt;a href="http://www.confreaks.com/videos/4119-elixirconf2014-opening-keynote-think-different"&gt;how Elixir can change the way you code&lt;/a&gt; or &lt;a href="http://www.confreaks.com/videos/4131-elixirconf2014-otp-in-production-the-nitty-gritty-details-of-game-servers"&gt;even hear stories of how Elixir is being used in production&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, by popular demand, we have &lt;a href="http://www.stickermule.com/user/1070631438/stickers"&gt;released some Elixir stickers&lt;/a&gt;, which are available with a discounted price to celebrate v1.0!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v0.15.0 released</title>
    <link href="http://elixir-lang.org/blog/2014/08/07/elixir-v0-15-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2014-08-07T00:00:00+00:00</updated>
    <id>/blog/2014/08/07/elixir-v0-15-0-released</id>
    <content type="html">&lt;p&gt;Hello everyone!&lt;/p&gt;

&lt;p&gt;We are glad to announce v0.15.0 has been released. We have spent the last 2 months tidying up the existing APIs, ensuring consistency, improving performance and more. As a result, v0.15.0 is the last minor branch before Elixir v1.0!&lt;/p&gt;

&lt;p&gt;There are also no more planned deprecations nor backward incompatible changes which means it is extremely likely that code that runs on v0.15.0 will run exactly the same on Elixir v1.0.&lt;/p&gt;

&lt;p&gt;If you are interested in the specific details for this release, &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.15.0/CHANGELOG.md"&gt;please check our CHANGELOG&lt;/a&gt;. In this post, we will focus on three new features in this release: Logger, Mix aliases, the fresh Elixir Web Installer for Windows, and share some exciting news at the end!&lt;/p&gt;

&lt;h2 id="logger"&gt;Logger&lt;/h2&gt;

&lt;p&gt;Elixir now ships with a new application called logger. This application provides &lt;a href="https://hexdocs.pm/logger/Logger.html"&gt;the Logger module&lt;/a&gt;, which is the main API developers will use for logging:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="kn"&gt;require&lt;/span&gt; &lt;span class="no"&gt;Logger&lt;/span&gt;
&lt;span class="no"&gt;Logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;hello"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;By default, the code above will log the following message to your console:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;10:27:39.083 [debug] hello
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Logger provides multiple backends to where messages are logged. For now Elixir ships only with a console backend but there are developers already working on file (with support to external log rotation) and &lt;a href="https://en.wikipedia.org/wiki/Syslog"&gt;syslog&lt;/a&gt; backends.&lt;/p&gt;

&lt;p&gt;When we started Logger, the main objective was to translate Erlang messages into Elixir, so terms are formatted in Elixir syntax. Before this release, the following code&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;oops"&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;logged the following report:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;=ERROR REPORT==== 7-Aug-2014::10:35:59 ===
** Task &amp;lt;0.59.0&amp;gt; terminating
** Started from &amp;lt;0.53.0&amp;gt;
** When function  == #Fun&amp;lt;erl_eval.20.90072148&amp;gt;
**      arguments == []
** Reason for termination ==
** {#{'__exception__' =&amp;gt; true,'__struct__' =&amp;gt; 'Elixir.RuntimeError',message =&amp;gt; &amp;lt;&amp;lt;"oops"&amp;gt;&amp;gt;},
    [{'Elixir.Task.Supervised',do_apply,2,
                               [{file,"lib/task/supervised.ex"},{line,70}]},
     {'Elixir.Task.Supervised',async,3,
                               [{file,"lib/task/supervised.ex"},{line,15}]},
     {proc_lib,init_p_do_apply,3,[{file,"proc_lib.erl"},{line,239}]}]}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now, with Logger, we get this report:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;10:37:22.457 [error] Task #PID&amp;lt;0.72.0&amp;gt; started from #PID&amp;lt;0.60.0&amp;gt; terminating
Function: #Function&amp;lt;20.90072148/0 in :erl_eval.expr/5&amp;gt;
    Args: []
** (exit) an exception was raised:
    ** (RuntimeError) oops
        (elixir) lib/task/supervised.ex:70: Task.Supervised.do_apply/2
        (elixir) lib/task/supervised.ex:15: Task.Supervised.async/3
        (stdlib) proc_lib.erl:239: :proc_lib.init_p_do_apply/3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As soon as we started working on Logger, we realized we could go further than simply translating Erlang messages and provide a fully featured logger library. At this moment, Logger also supports:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;4 log levels: debug, info, warn and error&lt;/li&gt;
  &lt;li&gt;Custom formatting: you can specify a format string that tells exactly how messages should be logged. The default string is: “$time $metadata[$level] $message\n” but &lt;a href="https://hexdocs.pm/logger/Logger.Formatter.html"&gt;many attributes are supported&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Custom translators: so you can translate log messages coming from any Erlang application into Elixir syntax&lt;/li&gt;
  &lt;li&gt;Metadata: metadata allows developers to store information in the current process that will be available to all logged messages. For example, a web application can generate a &lt;code class="highlighter-rouge"&gt;request_id&lt;/code&gt;, store it as metadata, and all messages logged during that request will be properly identified with &lt;code class="highlighter-rouge"&gt;request_id=...&lt;/code&gt; in the log&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We have also relied a lot on the &lt;a href="https://www.youtube.com/watch?v=8BNpOHFvg_Q"&gt;research and work done by Andrew Thompson and the folks at Basho behind Lager&lt;/a&gt; to ensure our logger is performant and robust. On this front, Logger&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;alternates between sync and async modes when logging messages to keep it performant when required but also apply back-pressure when under stress&lt;/li&gt;
  &lt;li&gt;formats and truncates messages on the client to avoid clogging the backends&lt;/li&gt;
  &lt;li&gt;provide a highwater mark around Erlang’s error_logger to avoid it from overflowing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We are looking forward to everyone’s feedback on using Logger more and more in production.&lt;/p&gt;

&lt;h2 id="mix-aliases"&gt;Mix aliases&lt;/h2&gt;

&lt;p&gt;Mix is Elixir’s build tool. Mix knows how to manage your dependencies, compile &amp;amp; test your projects and much more. We have designed Mix, since day one, to be extensible. Developers were always able to define new tasks by simply defining a module:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;Mix&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Tasks&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Hello&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="no"&gt;Mix&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Task&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="no"&gt;IO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;puts&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;Hello world"&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The task above can now be invoked as &lt;code class="highlighter-rouge"&gt;mix hello&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Defining custom Mix tasks is useful for projects and libraries that want to better integrate with the standard development workflow for Elixir. However, it is a bit verbose for creating one-off tasks or tasks to be used only locally in a given project.&lt;/p&gt;

&lt;p&gt;Furthermore, so far Mix did not allow developers to extend existing tasks. For example, imagine you want to perform some extra work when &lt;code class="highlighter-rouge"&gt;mix clean&lt;/code&gt; is invoked. Up to this release, it was not possible.&lt;/p&gt;

&lt;p&gt;Mix aliases solve both problems by providing a simple API for defining and overriding aliases. All projects that use Mix contain a &lt;code class="highlighter-rouge"&gt;mix.exs&lt;/code&gt; file with the project configuration. In order to define an alias, you just need to add a new key to your project configuration:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;MyProject&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="no"&gt;Mix&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Project&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;app:&lt;/span&gt; &lt;span class="ss"&gt;:my_project&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
     &lt;span class="ss"&gt;aliases:&lt;/span&gt; &lt;span class="n"&gt;aliases&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;aliases&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;c:&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;compile"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
     &lt;span class="ss"&gt;hello:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;print_hello&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
     &lt;span class="ss"&gt;clean:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;clean"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;clean_vendor&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;print_hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;IO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;puts&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;Hello world"&lt;/span&gt;
  &lt;span class="k"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;clean_vendor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;File&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rm_rf!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;vendor"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In the project above, we have defined three aliases:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;mix c&lt;/code&gt; - is now a shortcut to &lt;code class="highlighter-rouge"&gt;mix compile&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;mix hello&lt;/code&gt; - is equivalent to the &lt;code class="highlighter-rouge"&gt;Mix.Tasks.Hello&lt;/code&gt; we have defined earlier, although now it is more easily defined as an alias&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;mix clean&lt;/code&gt; - extends the existing &lt;code class="highlighter-rouge"&gt;clean&lt;/code&gt; task to ensure we invoke &lt;code class="highlighter-rouge"&gt;clean_vendor/1&lt;/code&gt; afterwards&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In other words, aliases can be three different structures:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A string containing the task and arguments to be invoked&lt;/li&gt;
  &lt;li&gt;An anonymous function (that is invoked passing the task arguments)&lt;/li&gt;
  &lt;li&gt;A list containing strings or anonymous functions&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can find more information about aliases by reading the &lt;a href="https://hexdocs.pm/mix/"&gt;Mix documentation&lt;/a&gt; (there is a section about Aliases around the middle).&lt;/p&gt;

&lt;p&gt;We also would like to thank &lt;a href="https://github.com/raynes"&gt;Anthony Grimes&lt;/a&gt; for the support and &lt;a href="https://github.com/technomancy"&gt;Phil Halgelberg&lt;/a&gt; for &lt;a href="https://github.com/technomancy/leiningen"&gt;the work on Lein&lt;/a&gt; which Mix borrows a lot from.&lt;/p&gt;

&lt;h2 id="elixir-web-installer-for-windows"&gt;Elixir Web Installer for Windows&lt;/h2&gt;

&lt;p&gt;At the beginning of this summer, &lt;a href="https://github.com/chyndman"&gt;Chris Hyndman&lt;/a&gt; joined us as a Google Summer of Code student to help us improve the Elixir story on Windows. Chris has been essential in:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Guaranteeing our test suite is green on Windows, fixing many bugs in the process;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/elixir-lang/elixir/wiki/Windows"&gt;Documenting how to compile Elixir from source on Windows&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Ensuring important projects like our &lt;a href="https://github.com/devinus/markdown/pull/7"&gt;C markdown processor&lt;/a&gt; compiles on Windows&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Chris has also built an &lt;a href="https://github.com/elixir-lang/elixir-windows-setup"&gt;Elixir Web Installer for Windows&lt;/a&gt;. The web installer checks all available Elixir versions and allows you to pick which one to install. It will also fetch and install Erlang in your machine in case it has not been installed yet.&lt;/p&gt;

&lt;p&gt;If you want to give Elixir and the Web Installer a try, you can &lt;a href="https://repo.hex.pm/elixir-websetup.exe"&gt;download the current version here&lt;/a&gt;. And, if &lt;a href="https://chocolatey.org/"&gt;Chocolatey&lt;/a&gt; is your thing, remember you can also install Elixir on Windows by running &lt;code class="highlighter-rouge"&gt;cinst elixir&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="welcome-alexei"&gt;Welcome Alexei!&lt;/h2&gt;

&lt;p&gt;With v0.15.0, we also would like to welcome &lt;a href="https://github.com/alco"&gt;Alexei&lt;/a&gt; to the team of Elixir Maintainers! Alexei was one of the first to actively participate in the Elixir community and he has done an excellent job in guaranteeing quality throughout it, be it in the code, documentation, wiki or website.&lt;/p&gt;

&lt;p&gt;Alexei is also interested in how we can extend our tooling to the Erlang ecosystem as a whole, bringing Mix and Hex (our package manager) to more developers as well as adding tasks that are specific to Erlang projects.&lt;/p&gt;

&lt;h2 id="whats-next"&gt;What’s next?&lt;/h2&gt;

&lt;p&gt;We are very close to launch Elixir v1.0! All planned features are already in Elixir’s codebase and at the moment there are only &lt;a href="https://github.com/elixir-lang/elixir/issues?q=is%3Aopen+is%3Aissue+milestone%3Av1.0"&gt;four open issues in our tracker tagged with the v1.0 milestone&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Our estimated date for the first release candidate for Elixir v1.0 is August 30th. This means there is no better time to learn Elixir than now! If you haven’t started yet, you can get started with Elixir by reading &lt;a href="/getting-started/introduction.html"&gt;our Getting Started guide&lt;/a&gt; or by checking one of the many “Learning Resources” on the sidebar.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v0.14.0 released</title>
    <link href="http://elixir-lang.org/blog/2014/06/17/elixir-v0-14-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2014-06-17T00:00:00+00:00</updated>
    <id>/blog/2014/06/17/elixir-v0-14-0-released</id>
    <content type="html">&lt;p&gt;Hello everyone!&lt;/p&gt;

&lt;p&gt;We are glad to announce v0.14.0 has been released.&lt;/p&gt;

&lt;p&gt;Our previous release, &lt;a href="/blog/2014/04/21/elixir-v0-13-0-released/"&gt;v0.13.0&lt;/a&gt;, brought important changes to the language. Back then we have introduced a new associative data structure, called maps, and presented the concept of structs to replace Elixir records.&lt;/p&gt;

&lt;p&gt;With v0.14.0 we have expanded on the work started on v0.13.0, replacing records by structs and integrating OTP behaviours, applications, and configurations into Mix.&lt;/p&gt;

&lt;h2 id="derive"&gt;@derive&lt;/h2&gt;

&lt;p&gt;Maps are Elixir’s new associative data structure:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="p"&gt;%{&lt;/span&gt;&lt;span class="ss"&gt;key:&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;value"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;With maps, Elixir also introduced structs, that are basically raw, named maps:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;User&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;defstruct&lt;/span&gt; &lt;span class="ss"&gt;name:&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;age:&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="no"&gt;User&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;name:&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;jose"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; %User{name: "jose", age: 0}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Structs allow us to provide default values for a map fields. Structs also validate, at compilation time, that all fields given during the struct construction are valid fields. The following, for example, would fail:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="no"&gt;User&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;unknown:&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;field"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; ** (CompileError) iex:2: unknown key :unknown for struct User&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We say structs are &lt;em&gt;raw&lt;/em&gt; because they do not implement any of the protocols that are implemented for maps  by default. For instance, we can call &lt;code class="highlighter-rouge"&gt;Enum.each/2&lt;/code&gt; for a map, which uses the &lt;a href="https://hexdocs.pm/elixir/Enumerable.html"&gt;&lt;code class="highlighter-rouge"&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="p"&gt;%{&lt;/span&gt;&lt;span class="ss"&gt;foo:&lt;/span&gt; &lt;span class="ss"&gt;:bar&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
  &lt;span class="no"&gt;IO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;puts&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;Got &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;: &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; Got foo: bar&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;But such a call would fail for the User struct:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="no"&gt;User&lt;/span&gt;&lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
  &lt;span class="no"&gt;IO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;puts&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;Got &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;: &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; ** (Protocol.UndefinedError) protocol Enumerable not implemented for %User{age: 0, name: ""}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;However, in many situations, we may want to enumerate the keys and values in a struct. Before this release, it would require us to manually implement the &lt;code class="highlighter-rouge"&gt;Enumerable&lt;/code&gt; protocol for every struct.&lt;/p&gt;

&lt;p&gt;Elixir v0.14.0 solves this issue by introducing &lt;code class="highlighter-rouge"&gt;@derive&lt;/code&gt; which allows us to dynamically derive implementations for structs based on the implementation for maps:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;User&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="nv"&gt;@derive&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;Enumerable&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="n"&gt;defstruct&lt;/span&gt; &lt;span class="ss"&gt;name:&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;age:&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="no"&gt;User&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;name:&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;jose"&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
  &lt;span class="no"&gt;IO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;puts&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;Got &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;: &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; Got __struct__: Elixir.User&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; Got name: jose&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; Got age: 0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The deriving functionality can be customized by implementing &lt;code class="highlighter-rouge"&gt;PROTOCOL.Map.__deriving__/3&lt;/code&gt;. For example, a JSON protocol could define a &lt;code class="highlighter-rouge"&gt;JSON.Map.__deriving__/3&lt;/code&gt; function that derives specific implementations for every struct. Such implementations could access the struct fields and generate a JSON template at compilation time, avoiding work at runtime.&lt;/p&gt;

&lt;h2 id="protocol-consolidation"&gt;Protocol consolidation&lt;/h2&gt;

&lt;p&gt;In the example above, when we called &lt;code class="highlighter-rouge"&gt;Enum.each/2&lt;/code&gt;, it invoked the &lt;code class="highlighter-rouge"&gt;Enumerable&lt;/code&gt; protocol internally, which then checks if there is an implementation available for the &lt;code class="highlighter-rouge"&gt;User&lt;/code&gt; struct. This means that dispatching a protocol incurs some overhead to check if the implementation is available or not.&lt;/p&gt;

&lt;p&gt;While this behaviour is useful for development, in production all implementations for all protocols are usually known up-front, so we could avoid this overhead by doing a direct dispatch. That’s exactly what protocol consolidation does.&lt;/p&gt;

&lt;p&gt;Protocol consolidation checks all code paths in your project, looking for all protocols and all implementions. When all implementations are found it will recompile all protocols to have quick dispatch rules.&lt;/p&gt;

&lt;p&gt;You can invoke &lt;code class="highlighter-rouge"&gt;Protocol.consolidate/2&lt;/code&gt; to manually consolidate protocols. However, if you are inside a Mix project, you can consolidate all protocols by simply invoking &lt;code class="highlighter-rouge"&gt;mix compile.protocols&lt;/code&gt;. Type &lt;code class="highlighter-rouge"&gt;mix help compile.protocols&lt;/code&gt; in your terminal to get more information. This task should be invoked when deploying to production and we have opened issues in the Elixir buildpack as well as in the existing build tools so they automatically consolidade protocols for you.&lt;/p&gt;

&lt;h2 id="nested-access"&gt;Nested access&lt;/h2&gt;

&lt;p&gt;With v0.14.0, Elixir introduced functionality to traverse deeply nested data structures. To show this functionality let’s imagine we have a gaming application where users can be in different dungeons. Each dungeon may have many rooms and users can talk to each other only if they are in the same room.&lt;/p&gt;

&lt;p&gt;We can model the game’s dungeons with a Dungeon struct:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="no"&gt;Dungeon&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;name:&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;rooms:&lt;/span&gt; &lt;span class="p"&gt;%{}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The Dungeon can have many rooms and we keep them in a map, with the room id as key, and the Room struct as value:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="no"&gt;Room&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;id:&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;users:&lt;/span&gt; &lt;span class="no"&gt;HashDict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;A room has users and since we can possibly have hundreds of them, we store them in a HashDict, with the user id as key. Finally, the user may participate from different devices, so we need to keep a set of device codes in each user:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="no"&gt;User&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;id:&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;username:&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;device_codes:&lt;/span&gt; &lt;span class="no"&gt;HashSet&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The nested access functionality that ships with Elixir allows us to quickly access or update a nested value. For example, given a dungeon named &lt;code class="highlighter-rouge"&gt;dungeon&lt;/code&gt;, we can access all the device codes for a given user as follow:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;dungeon&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rooms&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;room_id&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;users&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;user_id&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;device_codes&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;With the nested access functionality, we can now update a nested path directly too. For example, if a user changes his name, we can change it directly with:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;put_in&lt;/span&gt; &lt;span class="n"&gt;dungeon&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rooms&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;room_id&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;users&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;user_id&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;new username"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;If the user signs out from one device, we can delete the code from that particular device:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;update_in&lt;/span&gt; &lt;span class="n"&gt;dungeon&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rooms&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;room_id&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;users&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;user_id&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;device_codes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="no"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;&amp;amp;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class="highlighter-rouge"&gt;put_in/2&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;update_in/2&lt;/code&gt; are macros that work as syntax sugar for the lower-level &lt;code class="highlighter-rouge"&gt;put_in/3&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;update_in/3&lt;/code&gt;, that expects the whole path to be given as a list:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;put_in&lt;/span&gt; &lt;span class="n"&gt;dungeon&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:rooms&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;room_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:users&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;user_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;new username"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can read more information about nested access in &lt;a href="https://hexdocs.pm/elixir/Access.html"&gt;the Access protocol documentation&lt;/a&gt; and in the docs for &lt;a href="https://hexdocs.pm/elixir/Kernel.html#get_in/2"&gt;&lt;code class="highlighter-rouge"&gt;get_in/2&lt;/code&gt;&lt;/a&gt; and friends.&lt;/p&gt;

&lt;h2 id="mix-and-otp"&gt;Mix and OTP&lt;/h2&gt;

&lt;p&gt;OTP is a set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications.&lt;/p&gt;

&lt;p&gt;In v0.14.0, Elixir closely integrates with OTP by providing modules for building &lt;a href="https://hexdocs.pm/elixir/GenServer.html"&gt;servers&lt;/a&gt;, &lt;a href="https://hexdocs.pm/elixir/Supervisor.html"&gt;supervisors&lt;/a&gt; and &lt;a href="https://hexdocs.pm/elixir/Application.html"&gt;applications&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We have also introduced the concepts of &lt;a href="https://hexdocs.pm/elixir/Agent.html"&gt;agents&lt;/a&gt; and the idea of &lt;a href="https://hexdocs.pm/elixir/Task.html"&gt;tasks&lt;/a&gt;, which can be supervised and distributed. Application configuration has been made first class in Mix, allowing developers to configure their dependencies, sometimes even using different configurations per environment (dev, test or prod by default).&lt;/p&gt;

&lt;p&gt;This functionality is at the core of building applications in Erlang and Elixir. For this reason we have published a new guide called &lt;a href="/getting-started/mix-otp/introduction-to-mix.html"&gt;Mix and OTP&lt;/a&gt; where we build a distributed key-value store to help explore all concepts mentioned above. The guide is quite fresh, so please do submit pull requests for typos and mistakes. Feedback is also welcome!&lt;/p&gt;

&lt;p&gt;Note “Mix and OTP” is our most advanced guide so far and it expects you to have read our introductory guide. In case you haven’t yet, you can &lt;a href="/getting-started/introduction.html"&gt;get started here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="whats-next"&gt;What’s next?&lt;/h2&gt;

&lt;p&gt;With v0.14.0 we have reached many of the milestones &lt;a href="/blog/2014/04/21/elixir-v0-13-0-released/#the-next-steps"&gt;we have set in the previous release&lt;/a&gt;. This brings us closer to Elixir v1.0 and only a handful of tasks are pending:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Provide an Elixir logger that knows how to print and format Elixir exceptions and stacktraces. Work has already started on this front as Elixir already prints errors coming from the application startup nicely;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Continue the work of cleaning up the &lt;a href="https://hexdocs.pm/elixir/Kernel.html"&gt;Kernel module&lt;/a&gt;. In v0.14.0, we added alternatives for conversion functions, like &lt;code class="highlighter-rouge"&gt;integer_to_binary/1&lt;/code&gt; to &lt;code class="highlighter-rouge"&gt;Integer.to_string/1&lt;/code&gt;, now they must be properly deprecated and removed;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Support mix aliases, allowing developers to easily define Mix shortcuts for their favorite tasks;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Solve all remaining &lt;a href="https://github.com/elixir-lang/elixir/issues?state=open"&gt;open issues&lt;/a&gt;. We have always kept the issues tracker tidy and there is little work left to solve the existing issues. Note we have also listed all &lt;a href="https://github.com/elixir-lang/elixir/issues?labels=Note%3ABackwards+incompatible&amp;amp;page=1&amp;amp;state=open"&gt;upcoming backwards incompatible changes&lt;/a&gt;. Many of those changes will actually be deprecated first and developers should be able to follow along without breaking changes in minor releases, but they are breaking changes in the sense they work in v0.14.0 but will work differently by the time v1.0 is released;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That’s all for now! Elixir developers can see &lt;a href="https://github.com/elixir-lang/elixir/releases/tag/v0.14.0"&gt;a summary of all changes in v0.14.0 in the release notes&lt;/a&gt;. In case you are new around here, you can get started with Elixir by reading &lt;a href="/getting-started/introduction.html"&gt;our Getting Started guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We hope to see you all this July at &lt;a href="http://elixirconf.com/"&gt;ElixirConf&lt;/a&gt;!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v0.13.0 released, hex.pm and ElixirConf announced</title>
    <link href="http://elixir-lang.org/blog/2014/04/21/elixir-v0-13-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2014-04-21T00:00:00+00:00</updated>
    <id>/blog/2014/04/21/elixir-v0-13-0-released</id>
    <content type="html">&lt;p&gt;Hello folks!&lt;/p&gt;

&lt;p&gt;Elixir v0.13.0 has been released. It contains changes that will effectively shape how developers will write Elixir code from now on, making it an important milestone towards v1.0! On this post we are going to cover some of those changes, the road to Elixir v1.0, as well as the announcement of &lt;a href="https://hex.pm"&gt;hex.pm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before we go into the changes, let’s briefly talk about ElixirConf!&lt;/p&gt;

&lt;h2 id="elixirconf"&gt;ElixirConf&lt;/h2&gt;

&lt;p&gt;We are excited to announce &lt;a href="http://elixirconf.com"&gt;ElixirConf&lt;/a&gt;, the first ever Elixir conference, happening July 25-26, 2014 in Austin, TX. The Call For Proposals is open and we are waiting for your talks!&lt;/p&gt;

&lt;p&gt;The registration is also open and we hope you will join us on this exciting event. We welcome Elixir developers and enthusiasts that are looking forward to be part of our thrilling community!&lt;/p&gt;

&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;

&lt;p&gt;In a nutshell, here is what new:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Elixir now runs on and requires Erlang R17;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;With Erlang R17, Elixir also adds support for maps, which are key-value data structures that supports pattern matching. We’ll explore maps, their features and limitations in this post;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Elixir v0.13 also provides structs, an alternative to Elixir records. Structs are more flexible than records, provide faster polymorphic operations, and still provide the same compile-time guarantees many came to love in records;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href="/getting-started/introduction.html"&gt;Getting Started guide&lt;/a&gt; was rewritten from scratch. The previous guide was comprised of 7 chapters and was about to become 2 years old. The new guide features 20 chapters, it explores the new maps and structs (which are part of this release), and it goes deeper into topics like IO and File handling. It also includes an extra guide, still in development, about &lt;a href="/getting-started/meta/quote-and-unquote.html"&gt;Meta-Programming in Elixir&lt;/a&gt;;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Elixir v0.13 provides a new comprehension syntax that not only works with lists, but with any &lt;a href="https://hexdocs.pm/elixir/Enumerable.html"&gt;&lt;code class="highlighter-rouge"&gt;Enumerable&lt;/code&gt;&lt;/a&gt;. The output of a comprehension is also extensible via the &lt;a href="https://hexdocs.pm/elixir/Collectable.html"&gt;&lt;code class="highlighter-rouge"&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mix, Elixir’s build tool, has been improved in order to provide better workflows when compiling projects and working with dependencies;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There are many other changes, like the addition of &lt;a href="https://hexdocs.pm/elixir/StringIO.html"&gt;StringIO&lt;/a&gt;, support for &lt;a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html"&gt;tags and filters in ExUnit&lt;/a&gt; and more. Please check the &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.13.0/CHANGELOG.md"&gt;CHANGELOG&lt;/a&gt; for the complete list.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Even with all those improvements, Elixir v0.13.0 is backwards compatible with Elixir v0.12.5 and upgrading should be a clean process.&lt;/p&gt;

&lt;h2 id="maps"&gt;Maps&lt;/h2&gt;

&lt;p&gt;Maps are key-value data structures:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; map = %{"hello" =&amp;gt; :world}
%{"hello" =&amp;gt; :world}
iex&amp;gt; map["hello"]
:world
iex&amp;gt; map[:other]
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Maps do not have a explicit ordering and keys and values can be any term.&lt;/p&gt;

&lt;p&gt;Maps can be pattern matched on:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; %{"hello" =&amp;gt; world} = map
%{"hello" =&amp;gt; :world}
iex&amp;gt; world
:world
iex&amp;gt; %{} = map
%{"hello" =&amp;gt; :world}
iex&amp;gt; %{"other" =&amp;gt; value} = map
** (MatchError) no match of right hand side value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A map pattern will match any map that has all the keys specified in the pattern. The values for the matching keys must also match. For example, &lt;code class="highlighter-rouge"&gt;%{"hello" =&amp;gt; world}&lt;/code&gt; will match any map that has the key &lt;code class="highlighter-rouge"&gt;"hello"&lt;/code&gt; and assign the value to &lt;code class="highlighter-rouge"&gt;world&lt;/code&gt;, while &lt;code class="highlighter-rouge"&gt;%{"hello" =&amp;gt; "world"}&lt;/code&gt; will match any map that has the key &lt;code class="highlighter-rouge"&gt;"hello"&lt;/code&gt; with value equals to &lt;code class="highlighter-rouge"&gt;"world"&lt;/code&gt;. An empty map pattern (&lt;code class="highlighter-rouge"&gt;%{}&lt;/code&gt;) will match all maps.&lt;/p&gt;

&lt;p&gt;Developers can use the functions in the &lt;a href="https://hexdocs.pm/elixir/Map.html"&gt;&lt;code class="highlighter-rouge"&gt;Map&lt;/code&gt; module&lt;/a&gt; to work with maps. For more information on maps and how they compare to other associative data structures in the language, please check the &lt;a href="/getting-started/keywords-and-maps.html"&gt;Maps chapter in our new Getting Started guide&lt;/a&gt;. Elixir Sips has also released two episodes that cover maps (&lt;a href="http://elixirsips.com/episodes/054_maps_part_1.html"&gt;part 1&lt;/a&gt; and &lt;a href="http://elixirsips.com/episodes/055_maps_part_2.html"&gt;part 2&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Maps also provide special syntax for creating, accessing and updating maps with atom keys:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; user = %{name: "john", age: 27}
%{name: "john", age: 27}
iex&amp;gt; user.name
"john"
iex&amp;gt; user = %{user | name: "meg"}
%{name: "meg", age: 27}
iex&amp;gt; user.name
"meg"
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both access and update syntax above expect the given keys to exist. Trying to access or update a key that does not exist raises an error:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; %{ user | address: [] }
** (ArgumentError) argument error
     :maps.update(:address, [], %{})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we will see, this functionality becomes very useful when working with structs.&lt;/p&gt;

&lt;h2 id="structs"&gt;Structs&lt;/h2&gt;

&lt;p&gt;Structs are meant to replace Elixir records. Records in Elixir are simply tuples supported by modules which store record metadata:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defrecord&lt;/span&gt; &lt;span class="no"&gt;User&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;name:&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;age:&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Internally, this record is represented as the following tuple:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="c1"&gt;# {tag, name, age}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="no"&gt;User&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Records can also be created and pattern matched on:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; user = User[name: "john"]
User[name: "john", age: 0]
iex&amp;gt; user.name
"john"
iex&amp;gt; User[name: name] = user
User[name: "john", age: 0]
iex&amp;gt; name
"john"
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pattern matching works because the record meta-data is stored in the User module which can be accessed when building patterns.&lt;/p&gt;

&lt;p&gt;However, records came with their own issues. First of all, since records were made of data (the underlying tuple) and a module (functions/behaviour), they were frequently misused as an attempt to bundle data and behaviour together in Elixir, for example:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defrecord&lt;/span&gt; &lt;span class="no"&gt;User&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;name:&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;age:&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;first_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;at&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="no"&gt;User&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;name:&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;john doe"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first_name&lt;/span&gt; &lt;span class="c1"&gt;#=&amp;gt; "john"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Not only that, records were often slow in protocol dispatches because every tuple can potentially be a record, sometimes leading to expensive checks at runtime.&lt;/p&gt;

&lt;p&gt;Since maps are meant to replace many cases of records in Erlang, we saw with the introduction of maps the perfect opportunity to revisit Elixir records as well. In order to understand the reasoning behind structs, let’s list the features we got from Elixir records:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A way to organize data by fields&lt;/li&gt;
  &lt;li&gt;Efficient in-memory representation and operations&lt;/li&gt;
  &lt;li&gt;Compile-time structures with compile-time errors&lt;/li&gt;
  &lt;li&gt;The basic foundation for polymorphism in Elixir&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Maps naturally solve issues &lt;code class="highlighter-rouge"&gt;1.&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;2.&lt;/code&gt; above. In particular, maps that have same keys share the same key-space in memory. That’s why the update operation &lt;code class="highlighter-rouge"&gt;%{map | ...}&lt;/code&gt; we have seen above is relevant: if we know we are updating an existing key, the new map created as result of the update operation can share the same key space as the old map without extra checks. For more details on why Maps are efficient, I would recommend &lt;a href="http://joearms.github.io/2014/02/01/big-changes-to-erlang.html"&gt;reading Joe’s blog post on the matter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Structs were added to address features &lt;code class="highlighter-rouge"&gt;3.&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;4.&lt;/code&gt;. A struct needs to be explicitly defined via &lt;code class="highlighter-rouge"&gt;defstruct&lt;/code&gt;:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;User&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;defstruct&lt;/span&gt; &lt;span class="ss"&gt;name:&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;age:&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now a &lt;code class="highlighter-rouge"&gt;User&lt;/code&gt; struct can be created without a need to explicitly list all necessary fields:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; user = %User{name: "john"}
%User{name: "john", age: 0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trying to create a struct with an unknown key raises an error during compilation:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; user = %User{address: []}
** (CompileError) unknown key :address for struct User
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Furthermore, every struct has a &lt;code class="highlighter-rouge"&gt;__struct__&lt;/code&gt; field which contains the struct name:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; user.__struct__
User
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code class="highlighter-rouge"&gt;__struct__&lt;/code&gt; field is also used for polymorphic dispatch in protocols, addressing issue &lt;code class="highlighter-rouge"&gt;4.&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It is interesting to note that structs solve both drawbacks we have earlier mentioned regarding records. Structs are purely data and polymorphic dispatch is now faster and more robust as it happens only for explicitly tagged structs.&lt;/p&gt;

&lt;p&gt;For more information on structs, check out the &lt;a href="/getting-started/structs.html"&gt;Structs chapter in the getting started guide&lt;/a&gt; (you may also want to read the new &lt;a href="/getting-started/protocols.html"&gt;Protocols chapter&lt;/a&gt; after it).&lt;/p&gt;

&lt;h2 id="maps-structs-and-the-future"&gt;Maps, structs and the future&lt;/h2&gt;

&lt;p&gt;With the introduction of maps and structs, some deprecations will arrive on upcoming releases. First of all, the &lt;code class="highlighter-rouge"&gt;ListDict&lt;/code&gt; data structure is being deprecated and phased out. Records are also being deprecated from the language, although it is going to be a longer process, as many projects and Elixir itself still use records in diverse occasions.&lt;/p&gt;

&lt;p&gt;Note though only Elixir records are being deprecated. Erlang records, which are basically syntax sugar around tuples, will remain in the language for the rare cases Elixir developers need to interact with Erlang libraries that provide records. In particular, the &lt;a href="https://hexdocs.pm/elixir/Record.html"&gt;Record&lt;/a&gt; has been updated to provide the new Record API (while keeping the old one for backwards compatibility).&lt;/p&gt;

&lt;p&gt;Finally, structs are still in active development and new features, like &lt;code class="highlighter-rouge"&gt;@derive&lt;/code&gt;, should land in upcoming Elixir releases. For those interested, the &lt;a href="https://gist.github.com/josevalim/b30c881df36801611d13"&gt;original maps and structs proposal is still availble&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="comprehensions"&gt;Comprehensions&lt;/h2&gt;

&lt;p&gt;Erlang R17 also introduced recursion to anonymous functions. This feature, while still not available from Elixir, allows Elixir to provide a more flexible and extensible comprehension syntax.&lt;/p&gt;

&lt;p&gt;The most common use case of a comprehension are &lt;a href="https://en.wikipedia.org/wiki/List_comprehension"&gt;list comprehensions&lt;/a&gt;. For example, we can get all the square values of elements in a list as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; for n &amp;lt;- [1, 2, 3, 4], do: n * n
[1, 4, 9, 16]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We say the &lt;code class="highlighter-rouge"&gt;n &amp;lt;- [1, 2, 3, 4]&lt;/code&gt; part is a comprehension generator. In previous Elixir versions, Elixir supported only lists in generators. In Elixir v0.13.0, any Enumerable is supported (ranges, maps, etc):&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; for n &amp;lt;- 1..4, do: n * n
[1, 4, 9, 16]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As in previous Elixir versions, there is also support for a bitstring generator. In the example below, we receive a stream of RGB pixels as a binary and break it down into triplets:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; pixels = &amp;lt;&amp;lt;213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15&amp;gt;&amp;gt;
iex&amp;gt; for &amp;lt;&amp;lt;r::8, g::8, b::8 &amp;lt;- pixels&amp;gt;&amp;gt;, do: {r, g, b}
[{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, a comprehension returns a list as a result. However the result of a comprehension can be inserted into different data structures by passing the &lt;code class="highlighter-rouge"&gt;:into&lt;/code&gt; option. For example, we can use bitstring generators with the &lt;code class="highlighter-rouge"&gt;:into&lt;/code&gt; option to easily remove all spaces in a string:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; for &amp;lt;&amp;lt;c &amp;lt;- " hello world "&amp;gt;&amp;gt;, c != ?\s, into: "", do: &amp;lt;&amp;lt;c&amp;gt;&amp;gt;
"helloworld"
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sets, maps and other dictionaries can also be given with the &lt;code class="highlighter-rouge"&gt;:into&lt;/code&gt; option. In general, the &lt;code class="highlighter-rouge"&gt;:into&lt;/code&gt; accepts any structure as long as it implements the &lt;a href="https://hexdocs.pm/elixir/Collectable.html"&gt;&lt;code class="highlighter-rouge"&gt;Collectable&lt;/code&gt; protocol&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For example, the &lt;code class="highlighter-rouge"&gt;IO&lt;/code&gt; module provides streams, that are both &lt;code class="highlighter-rouge"&gt;Enumerable&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Collectable&lt;/code&gt;. You can implement an echo terminal that returns whatever is typed into the shell, but in upcase, using comprehensions:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-iex"&gt;iex&amp;gt; stream = IO.stream(:stdio, :line)
iex&amp;gt; for line &amp;lt;- stream, into: stream do
...&amp;gt;   String.upcase(line) &amp;lt;&amp;gt; "\n"
...&amp;gt; end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes comprehensions useful not only for working with in-memory collections but also with files, io devices, and other sources. In future releases, we will continue exploring how to make comprehensions more expressive, following in the footsteps of other functional programming research on the topic (like Comprehensive Comprehensions and Parallel Comprehensions).&lt;/p&gt;

&lt;h2 id="mix-workflows"&gt;Mix workflows&lt;/h2&gt;

&lt;p&gt;The last big change we want to discuss in this release are the improvements done to Mix, Elixir’s build tool. Mix is an essential tool to Elixir developers and helps developers to compile their projects, manage their dependencies, run tests and so on.&lt;/p&gt;

&lt;p&gt;In previous releases, Mix was used to download and compile dependencies per environment. That meant the usual workflow was less than ideal: every time a dependency was updated, developers had to explicitly fetch and compile the dependencies for each environment. The workflow would be something like:&lt;/p&gt;

&lt;div class="language-bash highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;mix deps.get
&lt;span class="gp"&gt;$ &lt;/span&gt;mix compile
&lt;span class="gp"&gt;$ &lt;/span&gt;&lt;span class="nv"&gt;MIX_ENV&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;test &lt;/span&gt;mix deps.get
&lt;span class="gp"&gt;$ &lt;/span&gt;mix &lt;span class="nb"&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In Elixir v0.13, &lt;code class="highlighter-rouge"&gt;mix deps.get&lt;/code&gt; only fetches dependencies and it does so accross all environments (unless an &lt;code class="highlighter-rouge"&gt;--only&lt;/code&gt; flag is specified). To support this new behaviour, dependencies now support the &lt;code class="highlighter-rouge"&gt;:only&lt;/code&gt; option:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;deps&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:ecto&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;github:&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;elixir-lang/ecto"&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
   &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:hackney&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;github:&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;benoitc/hackney"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;only:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:test&lt;/span&gt;&lt;span class="p"&gt;]}]&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Dependencies now are also automatically compiled before you run a command. For example, &lt;code class="highlighter-rouge"&gt;mix compile&lt;/code&gt; will automatically compile pending dependencies for the current environment. &lt;code class="highlighter-rouge"&gt;mix test&lt;/code&gt; will do the same for test dependencies and so on, interrupting less the developer workflow.&lt;/p&gt;

&lt;h2 id="hexpm"&gt;hex.pm&lt;/h2&gt;

&lt;p&gt;This release also marks the announcement of &lt;a href="https://hex.pm/"&gt;hex.pm&lt;/a&gt;, a package manager for the Erlang VM. Hex allows you to package and publish your projects while fetching them and performing dependency resolution in your applications.&lt;/p&gt;

&lt;p&gt;Currently Hex only integrates with Mix and contributions to extend it to other tools and other languages in the Erlang VM are welcome!&lt;/p&gt;

&lt;h2 id="the-next-steps"&gt;The next steps&lt;/h2&gt;

&lt;p&gt;As seen in this announcement, this release dictates many of the developments that will happen in Elixir and its community in the following weeks. All projects are recommended to start moving from records to structs, paving the way for the deprecation of records before 1.0.&lt;/p&gt;

&lt;p&gt;The next months will also focus on integrating Elixir more tightly to OTP. During the keynote at Erlang Factory, &lt;a href="https://www.youtube.com/watch?v=Djv4C9H9yz4"&gt;Catalyse Change&lt;/a&gt;, Dave Thomas and I argued that there are many useful patterns, re-implemented everyday by developers, that could make development more productive within the Erlang VM if exposed accordingly.&lt;/p&gt;

&lt;p&gt;That said, in the next months we plan to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Integrate applications configuration (provided by OTP) right into Mix;&lt;/li&gt;
  &lt;li&gt;Provide an Elixir logger that knows how to print and format Elixir exceptions and stacktraces;&lt;/li&gt;
  &lt;li&gt;Properly expose the functionality provided by Applications, Supervisors, GenServers and GenEvents and study how they can integrate with Elixir. For example, how to consume events from GenEvent as a &lt;a href="https://hexdocs.pm/elixir/Stream.html"&gt;stream of data&lt;/a&gt;?&lt;/li&gt;
  &lt;li&gt;Study how patterns like tasks and agents can be integrated into the language, often picking up the lessons learned by libraries like &lt;a href="http://e2project.org/erlang.html"&gt;e2&lt;/a&gt; and &lt;a href="http://www.erlang.org/doc/man/rpc.html"&gt;functionality exposed by OTP itself&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;Rewrite the Mix and ExUnit guides to focus on applications and OTP as a whole, rebranding it to “Building Apps with Mix and OTP”;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can learn more about Elixir in our &lt;a href="/getting-started/introduction.html"&gt;Getting Started guide&lt;/a&gt; and download this release in the &lt;a href="https://github.com/elixir-lang/elixir/releases/tag/v0.13.0"&gt;v0.13 announcement&lt;/a&gt;. We hope to see you at &lt;a href="http://elixirconf.com/"&gt;ElixirConf&lt;/a&gt; as well as pushing your packages to &lt;a href="https://hex.pm/"&gt;hex.pm&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v0.12.0 released</title>
    <link href="http://elixir-lang.org/blog/2013/12/15/elixir-v0-12-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2013-12-15T00:00:00+00:00</updated>
    <id>/blog/2013/12/15/elixir-v0-12-0-released</id>
    <content type="html">&lt;p&gt;Elixir v0.12.0 has been released with improved enumerables, build patterns and welcoming a new member to our team.&lt;/p&gt;

&lt;h2 id="enumerables"&gt;Enumerables&lt;/h2&gt;

&lt;p&gt;In previous versions, the Enumerable protocol was based on reduce/fold, and while it is very efficient for operations like &lt;code class="highlighter-rouge"&gt;map&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;reduce&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;filter&lt;/code&gt;, it was sub-optimal for operations that need to halt, like &lt;code class="highlighter-rouge"&gt;take&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;take_while&lt;/code&gt;, and it made it impossible for operations like &lt;code class="highlighter-rouge"&gt;zip&lt;/code&gt; to be implemented.&lt;/p&gt;

&lt;p&gt;In v0.12.0, Elixir’s Enumerable protocol has been extended to allow suspension and halting mechanisms, making operations like &lt;code class="highlighter-rouge"&gt;take&lt;/code&gt; simpler and operations that require interleaving, like &lt;code class="highlighter-rouge"&gt;zip&lt;/code&gt;, possible.&lt;/p&gt;

&lt;p&gt;Although most users don’t need to concern with the implementation of the Enumerable protocol, the side-effect is that both &lt;code class="highlighter-rouge"&gt;Enum&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Stream&lt;/code&gt; modules have been considerably extended and improved in this release, with more than 15 new functions added to the &lt;code class="highlighter-rouge"&gt;Stream&lt;/code&gt; module.&lt;/p&gt;

&lt;h2 id="mix"&gt;Mix&lt;/h2&gt;

&lt;p&gt;The tool that received most improvements in this release was Mix. The biggest change is that Mix no longer compiles projects in place but to the &lt;code class="highlighter-rouge"&gt;_build&lt;/code&gt; directory. For example, take the &lt;a href="https://github.com/elixir-lang/ecto"&gt;Ecto project&lt;/a&gt; that &lt;a href="https://github.com/elixir-lang/ecto/blob/master/mix.exs#L24-L25"&gt;depends on &lt;code class="highlighter-rouge"&gt;postgrex&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;poolboy&lt;/code&gt;&lt;/a&gt;. When compiled, all the artifacts will be placed in the &lt;code class="highlighter-rouge"&gt;_build&lt;/code&gt; directory like this:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;_build
└── shared
    └── lib
        ├── ecto
        │   └── ebin
        |   └── priv
        ├── poolboy
        │   └── ebin
        └── postgrex
            └── ebin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;For those familiar with Erlang’s OTP, this is similar to the structure used by OTP when releasing your software. So this new structure makes our software one step close to production and guarantee it is designed correctly since day 1.&lt;/p&gt;

&lt;p&gt;This approach comes with the &lt;code class="highlighter-rouge"&gt;:build_per_environment&lt;/code&gt; option which, when set to true, creates a different build per environment (&lt;code class="highlighter-rouge"&gt;dev&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;test&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;production&lt;/code&gt; or more). Extremely useful when a project compile different artifacts depending on the compilation environment.&lt;/p&gt;

&lt;p&gt;Mix has also added support to optional dependencies and improved common patterns, like the usage of umbrella apps.&lt;/p&gt;

&lt;h2 id="welcome-eric"&gt;Welcome, Eric!&lt;/h2&gt;

&lt;p&gt;With this release, we also want to welcome &lt;a href="https://github.com/ericmj"&gt;Eric MJ&lt;/a&gt; to the Elixir Team. He has done fantastic work on Elixir, helping us maintain the codebase and working on many of the important features from previous releases and now many more to come.&lt;/p&gt;

&lt;p&gt;Eric is also maintainer of both &lt;a href="https://github.com/elixir-lang/ecto"&gt;Ecto&lt;/a&gt; and &lt;a href="https://github.com/ericmj/postgrex"&gt;Postgrex&lt;/a&gt; projects. Which are proving to be very useful to the Elixir community too!&lt;/p&gt;

&lt;h2 id="tidying-up"&gt;Tidying up&lt;/h2&gt;

&lt;p&gt;There were other small changes, like additions to the &lt;code class="highlighter-rouge"&gt;Float&lt;/code&gt; module and improvements the to the typespec syntax. To see the full list, please &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.12.0/CHANGELOG.md"&gt;see the CHANGELOG&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Give Elixir a try! You can start with our &lt;a href="/getting-started/introduction.html"&gt;getting started guide&lt;/a&gt;, or check out our sidebar for other learning resources.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir's new continuable enumerators</title>
    <link href="http://elixir-lang.org/blog/2013/12/11/elixir-s-new-continuable-enumerators/"/>
    <author>
      <name>Peter Minten</name>
    </author>
    <updated>2013-12-11T00:00:00+00:00</updated>
    <id>/blog/2013/12/11/elixir-s-new-continuable-enumerators</id>
    <content type="html">&lt;p&gt;As you may have heard in the upcoming 0.12.0 release Elixir’s enumerators gained
some new features. In this blog post I’ll explain what’s new, what it enables
and how it works.&lt;/p&gt;

&lt;p&gt;For those of you who use the development version of Elixir these changes are
already available. For the exact differences in code you can look at the
&lt;a href="https://github.com/elixir-lang/elixir/pull/1922"&gt;relevant pull request&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="a-recap-of-enumerators-and-some-terminology"&gt;A recap of enumerators, and some terminology&lt;/h2&gt;

&lt;p&gt;The basic idea of enumerators is that you traverse some data structure or
resource (lines from a file) by putting the thing that is traversed in control.
That is if you’re reading from a file you have a loop that reads lines from a
file and for each line calls a function. Just calling a function isn’t all that
useful for most tasks as there’d be no way to remember previous lines (ugly
hacks aside), so some accumulator value is passed to the function and a new
accumulator is returned by it.&lt;/p&gt;

&lt;p&gt;For example here’s how you can count the total length of strings in a list.&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;Enumerable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Often the actual call to &lt;code class="highlighter-rouge"&gt;Enumerable.reduce/3&lt;/code&gt; is hidden inside another
function.  Say that we want to define a &lt;code class="highlighter-rouge"&gt;sum&lt;/code&gt; function. The usual way is to
write it like this:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coll&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="no"&gt;Enumerable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coll&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This could get called as &lt;code class="highlighter-rouge"&gt;Enum.map(1..10, &amp;amp;(&amp;amp;1 * &amp;amp;1)) |&amp;gt; sum()&lt;/code&gt; to get the sum of
squares. Desugaring this means &lt;code class="highlighter-rouge"&gt;sum(Enum.map(1..10, &amp;amp;(&amp;amp;1 * &amp;amp;1)))&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The general pattern is this:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;outer_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coll&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="no"&gt;Enumerable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coll&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;initial_consumer_acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;something_that_returns_an_enumerable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;outer_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You’ll notice the slightly uncommon terminology of “outer function” and
“consumer” (normally called an “iteratee”). That’s intentional, naming an
iteratee a consumer better reflects that it consumes values.&lt;/p&gt;

&lt;p&gt;Along the same lines I call the reduce function for a specific enumerable a
producer, it produces values which are given to a consumer.&lt;/p&gt;

&lt;p&gt;The outer function is the function to which the enumerable is passed.
Syntactically it looks like this is the consumer, but it’s really a function
that combines the producer and the consumer. For simple consumers (say &lt;code class="highlighter-rouge"&gt;fn x,
acc -&amp;gt; length(x) + acc end&lt;/code&gt;) the consumer will often be written directly in the
source text of the outer function, but let’s try to keep those concepts
distinguished.&lt;/p&gt;

&lt;h2 id="two-issues-with-classic-elixir-enumerators"&gt;Two issues with classic Elixir enumerators&lt;/h2&gt;

&lt;p&gt;Enumerators are great, but they have their limitations. One issue is that it’s
not possible to define a function that only returns at most 3 elements without
traversing all elements or using ugly tricks such as &lt;code class="highlighter-rouge"&gt;throw&lt;/code&gt; (with a
&lt;code class="highlighter-rouge"&gt;try...catch&lt;/code&gt; construct in the outer function). The &lt;code class="highlighter-rouge"&gt;throw&lt;/code&gt; trick is used in
&lt;code class="highlighter-rouge"&gt;Enum&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Stream&lt;/code&gt; to implement functions such as &lt;code class="highlighter-rouge"&gt;Enum.take/2&lt;/code&gt; and
&lt;code class="highlighter-rouge"&gt;Stream.take_while/2&lt;/code&gt;. It works, but it’s not what I’d call stylish.&lt;/p&gt;

&lt;p&gt;A bigger problem, that doesn’t have a workaround, is that there’s no way to
interleave two enumerables. That is, it’s not possible to define a function that
for two enumerables &lt;code class="highlighter-rouge"&gt;A&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;B&lt;/code&gt; returns a list &lt;code class="highlighter-rouge"&gt;[A1, B1, A2, B2, A3, ...]&lt;/code&gt;
(where &lt;code class="highlighter-rouge"&gt;A1&lt;/code&gt; is the first element of A) without first traversing both lists and
then interleaving the collected values. Interleaving is important because it’s
the basis of a zip function. Without interleaving you cannot implement
&lt;code class="highlighter-rouge"&gt;Stream.zip/2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The underlying problem, in both cases, is that the producer is fully in control.
The producer simply pushes out as many elements to the consumer as it wants and
then says “I’m done”. There’s no way aside from &lt;code class="highlighter-rouge"&gt;throw/raise&lt;/code&gt; for a consumer
to tell a producer “stop producing”. There is definitely no way to tell a
producer “stop for now but be prepared to continue where you left off later”.&lt;/p&gt;

&lt;h2 id="power-to-the-consumer"&gt;Power to the consumer!&lt;/h2&gt;

&lt;p&gt;At CodeMeshIO José Valim and Jessica Kerr sat down and discussed this problem.
They came up with a solution inspired by a &lt;a href="http://themonadreader.files.wordpress.com/2010/05/issue16.pdf"&gt;Monad.Reader
article&lt;/a&gt; (third
article). It’s an elegant extension of the old system, based on a simple idea.
Instead of returning only an accumulator at every step (for every produced
value) the consumer returns a combination of an accumulator and an instruction
to the producer. Three instructions are available:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;:cont&lt;/code&gt; - Keep producing.&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;:halt&lt;/code&gt; - Stop producing.&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;:suspend&lt;/code&gt; - Temporarily stop producing.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A consumer that always returns &lt;code class="highlighter-rouge"&gt;:cont&lt;/code&gt; makes the producer behave exactly the
same as in the old system. A consumer may return &lt;code class="highlighter-rouge"&gt;:halt&lt;/code&gt; to have the producer
terminate earlier than it normally would.&lt;/p&gt;

&lt;p&gt;The real magic is in &lt;code class="highlighter-rouge"&gt;:suspend&lt;/code&gt; though. It tells a producer to return the
accumulator and a continuation function.&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:suspended&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Enumerable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:cont&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:suspend&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:cont&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;After running this code &lt;code class="highlighter-rouge"&gt;n_&lt;/code&gt; will be &lt;code class="highlighter-rouge"&gt;3&lt;/code&gt; (1 + 2) and &lt;code class="highlighter-rouge"&gt;cont&lt;/code&gt; will be a
function. We’ll get back to &lt;code class="highlighter-rouge"&gt;cont&lt;/code&gt; in a minute but first take a look at some of
the new elements here. The initial accumulator has an instruction as well, so
you could suspend or halt a producer immediately, if you really want to. The
value passed to the consumer (&lt;code class="highlighter-rouge"&gt;n&lt;/code&gt;) does not contain the instruction. The return
value of the producer also has a symbol in it. Like with the instructions of
consumers there are three possible values:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;:done&lt;/code&gt; - Completed normally.&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;:halted&lt;/code&gt; - Consumer returned a &lt;code class="highlighter-rouge"&gt;:halt&lt;/code&gt; instruction.&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;:suspended&lt;/code&gt; - Consumer return a &lt;code class="highlighter-rouge"&gt;:suspend&lt;/code&gt; instruction.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Together with the other values returned the possible return values from a
producer are &lt;code class="highlighter-rouge"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:done,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;acc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:halted,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;acc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:suspended,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;acc,&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="err"&gt;continuation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Back to the continuation. A continuation is a function that given an accumulator
returns a new producer result. In other words it’s a way to swap out the
accumulator but keep the same producer in the same state.&lt;/p&gt;

&lt;h2 id="implementing-interleave"&gt;Implementing &lt;code class="highlighter-rouge"&gt;interleave&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Using the power of suspension it is now possible to create an interleave
function.&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;Interleave&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;step&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:suspend&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;af&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="no"&gt;Enumerable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;bf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="no"&gt;Enumerable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;do_interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;af&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="ss"&gt;:lists&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;do_interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt; &lt;span class="ss"&gt;:cont&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:suspended&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt; &lt;span class="ss"&gt;:cont&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
          &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:suspended&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class="n"&gt;do_interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:halted&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class="n"&gt;acc&lt;/span&gt;
          &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:done&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class="n"&gt;finish_interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:halted&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="n"&gt;acc&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:done&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="n"&gt;finish_interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;finish_interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a_or_b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;a_or_b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt; &lt;span class="ss"&gt;:cont&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:suspended&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a_or_b&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="n"&gt;finish_interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a_or_b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="n"&gt;acc&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="no"&gt;Interleave&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;interleave&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:d&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [1, :a, 2, :b, :c, :d]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Lets go through this step by step. The main &lt;code class="highlighter-rouge"&gt;interleave&lt;/code&gt; function first
partially applies &lt;code class="highlighter-rouge"&gt;Enumerable.reduce/3&lt;/code&gt; to get function values that work just
like the continuations. This makes things easier for &lt;code class="highlighter-rouge"&gt;do_interleave&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code class="highlighter-rouge"&gt;do_interleave&lt;/code&gt; function first calls &lt;code class="highlighter-rouge"&gt;a&lt;/code&gt; (&lt;code class="highlighter-rouge"&gt;af&lt;/code&gt; from &lt;code class="highlighter-rouge"&gt;interleave&lt;/code&gt;) with the
&lt;code class="highlighter-rouge"&gt;step&lt;/code&gt; function so that the available element of &lt;code class="highlighter-rouge"&gt;a&lt;/code&gt; gets added to the
accumulator and &lt;code class="highlighter-rouge"&gt;a&lt;/code&gt; immediately suspends afterwards. Then the same is done for
&lt;code class="highlighter-rouge"&gt;b&lt;/code&gt;. If either producer is done all the remaining elements of the other get
added to the accumulator list.&lt;/p&gt;

&lt;p&gt;Note that &lt;code class="highlighter-rouge"&gt;acc&lt;/code&gt; is sometimes used to mean a tuple like &lt;code class="highlighter-rouge"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:cont,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt; and
sometimes the accumulator value proper. It’s a bit confusing, yes.&lt;/p&gt;

&lt;p&gt;This example shows that through clever combination of an outer function
(&lt;code class="highlighter-rouge"&gt;do_interleave&lt;/code&gt;) and an inner function &lt;code class="highlighter-rouge"&gt;step&lt;/code&gt; two producers can be interleaved.&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The new system of enumerators certainly makes things a bit more complicated but
also adds power. I suspect many interesting and “interesting” functions can be
built on top of it.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v0.11.0 released</title>
    <link href="http://elixir-lang.org/blog/2013/11/05/elixir-v0-11-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2013-11-05T00:00:00+00:00</updated>
    <id>/blog/2013/11/05/elixir-v0-11-0-released</id>
    <content type="html">&lt;p&gt;After 4 months, Elixir v0.11.0 has been released with 832 commits since the previous minor release, done by more than 40 contributors. Although we have some great features in this release, the major focus in those 4 months was improving the common patterns used by the community and streamlining the existing workflows.&lt;/p&gt;

&lt;h2 id="iex"&gt;IEx&lt;/h2&gt;

&lt;p&gt;One of the tools that most received improvements in this release was our interactive shell. Such improvements come as no surprise as Elixir developers spend a good amount of time in the shell, which is great for development, allowing you to quickly try and load code, to production, where IEx can connect to remote nodes to inspect production information.&lt;/p&gt;

&lt;p&gt;The IEx helper &lt;code class="highlighter-rouge"&gt;h&lt;/code&gt;, responsible for showing documentation for existing modules and functions, has now been improved to rely on ANSI codes and nicely format the documentation. let’s take a look at the docs for the String module:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/contents/string-help.png" alt="String module docs" /&gt;&lt;/p&gt;

&lt;p&gt;This change goes in line with Elixir’s goal of providing first-class documentation, which makes documentation easily accessible at runtime, support to doctests and more.&lt;/p&gt;

&lt;p&gt;In this new release, IEx also supports a very simple debugging mechanism called &lt;code class="highlighter-rouge"&gt;IEx.pry&lt;/code&gt;. Let’s see an screenshot of it in action:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/contents/iex-pry.png" alt="IEx pry example" /&gt;&lt;/p&gt;

&lt;p&gt;In Elixir, your code runs in many processes that talk to each other and the Elixir shell is no different. &lt;code class="highlighter-rouge"&gt;IEx.pry&lt;/code&gt; allows another process to take over the shell, allowing the developer to inspect the binding and halt the execution of the process being “pried” (i.e. the one that invoked &lt;code class="highlighter-rouge"&gt;IEx.pry&lt;/code&gt;). We called this feature &lt;code class="highlighter-rouge"&gt;pry&lt;/code&gt; as a gentle reminder that you can only inspect existing information, you cannot change the binding over a pried process. For more information, check the docs for &lt;a href="https://hexdocs.pm/iex/IEx.html#pry/1"&gt;&lt;code class="highlighter-rouge"&gt;IEx.pry/1&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="exunit"&gt;ExUnit&lt;/h2&gt;

&lt;p&gt;&lt;a href="/blog/2013/07/13/elixir-v0-10-0-released/"&gt;In the previous release&lt;/a&gt;, we introduced great changes to ExUnit, like the support for the &lt;code class="highlighter-rouge"&gt;--trace&lt;/code&gt; option. This time we continued pushing improvements, like adding profiling to test cases (times can be seen with the &lt;code class="highlighter-rouge"&gt;--trace&lt;/code&gt; option), paving the way for other features like emitting warnings for test cases that are too slow.&lt;/p&gt;

&lt;p&gt;Another simple but significant change in ExUnit was the change in the default formatter to print changes as they come, instead of waiting until the suite is done running:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/contents/fast-fail.png" alt="ExUnit Fast Fail" /&gt;&lt;/p&gt;

&lt;p&gt;This change allows developer to get faster feedback from their test suites.&lt;/p&gt;

&lt;h2 id="mix"&gt;Mix&lt;/h2&gt;

&lt;p&gt;Since the early days, Elixir took ahold of the compilation process in order to provide a seamless compilation experience. &lt;a href="/blog/2012/04/24/a-peek-inside-elixir-s-parallel-compiler/"&gt;Elixir’s ParallelCompiler&lt;/a&gt; was introduced even before the first official release, allowing developers to harness all the cores in their computer to compile Elixir code. However, once the first release came out, every time you changed any file, the whole project had to be recompiled.&lt;/p&gt;

&lt;p&gt;In the past releases we have improved this process to only compile files that changed and their dependencies. For v0.11.0, we have improved this process to be faster and less conservative than the previous version.&lt;/p&gt;

&lt;p&gt;Mix has also improved support for umbrella projects, which are projects that contain multiple OTP applications, essential for building large projects. The current release allows sharing of dependencies between projects and faster and dependency resolution times.&lt;/p&gt;

&lt;h2 id="other-changes"&gt;Other changes&lt;/h2&gt;

&lt;p&gt;This release also introduces the new capture operator, which provides a convenient syntax for retrieving functions so they can be passed as arguments:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;all?&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="ss"&gt;:foo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:bar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:baz&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;is_atom&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Which can also be used for partially applying functions and macros:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;is_record&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;&amp;amp;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;Range&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can learn more about the &lt;a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#&amp;amp;/1"&gt;new capture operator in our docs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We have also pushed improvements to &lt;a href="https://hexdocs.pm/elixir/String.html"&gt;the String module&lt;/a&gt;, including new APIs. In particular, in order to know that &lt;code class="highlighter-rouge"&gt;String.length("josé")&lt;/code&gt; has length 4 (even though it takes 5 bytes to be represented in UTF-8), we need to use some algorithms defined by the Unicode Standard. These have been implemented as specified in the &lt;a href="http://www.unicode.org/reports/tr29/"&gt;extended grapheme cluster algorithm, defined in the version 6.3.0 of the Unicode Standard&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the optimization front, we have pushed the first iteration of a &lt;a href="https://groups.google.com/forum/#!topic/elixir-lang-core/RoXAUtoyjk4"&gt;feature called Protocol consolidation&lt;/a&gt;, which speeds up the polymorphic dispatch done by protocols, sometimes reducing the dispatching time to 10% of the original time. We will continue working in upcoming releases to integrate protocol consolidation as a regular part of the developer workflow.&lt;/p&gt;

&lt;p&gt;And finally, a minor but frequently asked feature has finally arrived into Elixir: variables follow the same rules as other identifiers in the language, which means developers can now name their variables &lt;code class="highlighter-rouge"&gt;is_atom?&lt;/code&gt;. For a general overview, &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/CHANGELOG.md"&gt;check out the CHANGELOG&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Give Elixir a try! You can start with our &lt;a href="/getting-started/introduction.html"&gt;getting started guide&lt;/a&gt;, or check out our sidebar for other learning resources.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PS:&lt;/strong&gt; We have just released v0.11.1 which addresses a regression in Mix and improves the dependencies update process.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir Design Goals</title>
    <link href="http://elixir-lang.org/blog/2013/08/08/elixir-design-goals/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2013-08-08T00:00:00+00:00</updated>
    <id>/blog/2013/08/08/elixir-design-goals</id>
    <content type="html">&lt;p&gt;During the last year, we have spoken at many conferences spreading the word about Elixir. We &lt;a href="https://vimeo.com/53221562"&gt;usually started with introducing the Erlang VM&lt;/a&gt;, then went on to talk about Elixir goals, saving some time at the end to do a live demo, showing some goodies like exchanging information between remote nodes and even hot code swapping.&lt;/p&gt;

&lt;p&gt;This post is a summary of those talks, focusing on the language goals: compatibility, productivity and extensibility.&lt;/p&gt;

&lt;h2 id="compatibility"&gt;Compatibility&lt;/h2&gt;

&lt;p&gt;Elixir is meant to be compatible with the Erlang VM and the existing ecosystem. When we talk about Erlang, we can break it into three parts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A functional programming language, called Erlang&lt;/li&gt;
  &lt;li&gt;A set of design principles, called OTP&lt;/li&gt;
  &lt;li&gt;The Erlang Virtual Machine, referred to as EVM or BEAM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Elixir runs in the same virtual machine and is compatible with OTP. Not only that, all the tools and libraries available in the Erlang ecosystem are also available in Elixir, simply because there is no conversion cost from calling Erlang from Elixir and vice-versa.&lt;/p&gt;

&lt;p&gt;We frequently say that &lt;strong&gt;the Erlang VM is Elixir’s strongest asset&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;All Elixir code is executed inside light-weight processes (actors), each with its own state, that exchange messages between each other. The Erlang VM multiplexes those processes onto many cores, making it trivial to run code concurrently.&lt;/p&gt;

&lt;p&gt;In fact if you compile any Elixir code, including the Elixir source, you will see all cores on your machine being used out of the box. With &lt;a href="http://www.parallella.org/board/"&gt;technologies like Parallella&lt;/a&gt; becoming more accessible and affordable, it is hard to ignore the power you can get out of the Erlang VM.&lt;/p&gt;

&lt;p&gt;Finally, the Erlang VM was designed to build systems that run forever, self-heal and scale. Joe Armstrong, one of Erlang’s creators, has recently given an excellent talk &lt;a href="http://www.infoq.com/presentations/self-heal-scalable-system"&gt;about the design decisions behind OTP and the VM&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Nothing that we are describing here is particularly new. Open source projects like CouchDB, Riak, RabbitMQ, Chef11 and companies like Ericsson, Heroku, Basho, Klarna and Wooga are already enjoying the benefits provided by the Erlang VM, some of them for quite a long time.&lt;/p&gt;

&lt;h2 id="productivity"&gt;Productivity&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Now we need to go meta. We should now think of a language design as being a pattern for language designs. A tool for making more tools of the same kind. […] A language design can no longer be a thing. It must be a pattern, a pattern for growth. A pattern for growing a pattern, for defining the patterns that programmers can use for their real work and main goals.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Guy Steele, keynote at the 1998 ACM OOPSLA conference on “Growing a Language”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Productivity is, in general, a hard goal to measure. A language productive for creating desktop applications may not be productive for mathematical computing. Productivity depends directly on the field in which you intend to use the language, the available tools in the ecosystem and how easy it is to create and extend those tools.&lt;/p&gt;

&lt;p&gt;For this reason, we have opted for a small language core. For example, while some languages have &lt;code class="highlighter-rouge"&gt;if&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;case&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;try&lt;/code&gt; and so on as language keywords, each with its own rules in the parser, &lt;strong&gt;in Elixir they are just macros&lt;/strong&gt;. This allows us to implement most of Elixir in Elixir and also allows developers to extend the language using the same tools we used to build the language itself, often extending the language to the specific domains they are working on.&lt;/p&gt;

&lt;p&gt;Here is an example of how someone would implement &lt;code class="highlighter-rouge"&gt;unless&lt;/code&gt;, which is a keyword in many languages, in Elixir:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmacro&lt;/span&gt; &lt;span class="k"&gt;unless&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;quote&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;!unquote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="kn"&gt;unquote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="no"&gt;true&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="no"&gt;IO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;puts&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;this will never be seen"&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Since a macro receives the code representation as arguments, we can simply convert an &lt;code class="highlighter-rouge"&gt;unless&lt;/code&gt; into an &lt;code class="highlighter-rouge"&gt;if&lt;/code&gt; at compile time.&lt;/p&gt;

&lt;p&gt;Macros are also the base construct for meta-programming in Elixir: the ability to write code that generates code. Meta-programming allows developers to easily get rid of boilerplate and create powerful tools. A common example mentioned in talks is how our test framework uses macros for expressiveness. Let’s see an example:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;ExUnit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;

&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;MathTest&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="no"&gt;ExUnit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Case&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;async:&lt;/span&gt; &lt;span class="no"&gt;true&lt;/span&gt;

  &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;adding two numbers"&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;assert&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="m"&gt;4&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The first thing to notice is the &lt;code class="highlighter-rouge"&gt;async: true&lt;/code&gt; option. When your tests do not have any side-effects, you can run them concurrently by passing the &lt;code class="highlighter-rouge"&gt;async: true&lt;/code&gt; option.&lt;/p&gt;

&lt;p&gt;Next we define a test case and we do an assertion with the &lt;code class="highlighter-rouge"&gt;assert&lt;/code&gt; macro. Simply calling &lt;code class="highlighter-rouge"&gt;assert&lt;/code&gt; would be a bad practice in many languages as it would provide a poor error report. In such languages, functions/methods like &lt;code class="highlighter-rouge"&gt;assertEqual&lt;/code&gt; or &lt;code class="highlighter-rouge"&gt;assert_equal&lt;/code&gt; would be the recommended way of performing such assertion.&lt;/p&gt;

&lt;p&gt;In Elixir, however, &lt;code class="highlighter-rouge"&gt;assert&lt;/code&gt; is a macro and as such it can look into the code being asserted and infer that a comparison is being made. This code is then transformed to provide a detailed error report when the test runs:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;1) test adding two numbers (MathTest)
   ** (ExUnit.ExpectationError)
                expected: 3
     to be equal to (==): 4
   at test.exs:7
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This simple example illustrates how a developer can leverage macros to provide a concise but powerful API. Macros have access to the whole compilation environment, being able to check the imported functions, macros, defined variables and more.&lt;/p&gt;

&lt;p&gt;Those examples are just scratching the surface of what can be achieved with macros in Elixir. For example, we are currently using macros to compile routes from a web application into a bunch of patterns that are highly optimizable by the VM, providing an expressive but heavily optimized routing algorithm.&lt;/p&gt;

&lt;p&gt;The macro system also caused a huge impact on the syntax, which we will discuss briefly before moving to the last goal.&lt;/p&gt;

&lt;h3 id="syntax"&gt;Syntax&lt;/h3&gt;

&lt;p&gt;Although syntax is usually one of the first topics that comes up when Elixir is being discussed, it was never a goal to simply provide a different syntax. Since we wanted to provide a macro system, we knew that the macro system would only be sane if we could represent Elixir syntax in terms of Elixir’s own data structures in a straight-forward fashion. With this goal in mind, we set out to design the first Elixir version, which looked like this:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;Hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;calculate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In the snippet above, we represent everything, except variables, as a function or a macro call. Notice keyword arguments like &lt;code class="highlighter-rouge"&gt;do:&lt;/code&gt; have been present since the first version. To this, we slowly added new syntax, making some common patterns more elegant while keeping the same underlying data representation. We soon added infix notation for operators:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;Hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;calculate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
    &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
  &lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The next step was to make parentheses optional:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;Hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;calculate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
    &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And finally we added &lt;code class="highlighter-rouge"&gt;do/end&lt;/code&gt; as convenience for the common &lt;code class="highlighter-rouge"&gt;do: (...)&lt;/code&gt; construct:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;Hello&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;calculate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
    &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Given my previous background in Ruby, it is natural that some of the constructs added were borrowed from Ruby. However, those additions were a by-product, and not a language goal.&lt;/p&gt;

&lt;p&gt;Many language constructs are also inspired by their Erlang counter-parts, like some of the control-flow macros, operators and containers. Notice how some Elixir code:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="c1"&gt;# A tuple&lt;/span&gt;
&lt;span class="n"&gt;tuple&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;# Adding two lists&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c1"&gt;# Case&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
  &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="ow"&gt;when&lt;/span&gt; &lt;span class="n"&gt;is_integer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;maps to Erlang:&lt;/p&gt;

&lt;div class="language-erlang highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="c"&gt;% A tuple
&lt;/span&gt;&lt;span class="nv"&gt;Tuple&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;}.&lt;/span&gt;

&lt;span class="c"&gt;% Adding two lists
&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;

&lt;span class="c"&gt;% Case
&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nv"&gt;Expr&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;Y&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;X&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="nv"&gt;Other&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="nb"&gt;is_integer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;Other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;Other&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id="extensibility"&gt;Extensibility&lt;/h2&gt;

&lt;p&gt;By building on top of a small core, most of the constructs in the language can be replaced and extended as required by developers to target specific domains. However, there is a particular domain that Elixir is inherently good at, which is building concurrent, distributed applications, thanks to OTP and the Erlang VM.&lt;/p&gt;

&lt;p&gt;Elixir complements this domain by providing a standard library with:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Unicode strings and unicode operations&lt;/li&gt;
  &lt;li&gt;A powerful unit test framework&lt;/li&gt;
  &lt;li&gt;More data structures like ranges, including novel implementations for sets and dictionaries&lt;/li&gt;
  &lt;li&gt;Polymorphic records (in contrast to Erlang’s compilation-time only records)&lt;/li&gt;
  &lt;li&gt;Strict and lazy enumeration APIs&lt;/li&gt;
  &lt;li&gt;Convenience functions for scripting, like working with paths and the filesystem&lt;/li&gt;
  &lt;li&gt;A project management tool to compile and test Elixir code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And much more.&lt;/p&gt;

&lt;p&gt;Most of the features above provide their own extensibility mechanisms, too. For example, take the &lt;code class="highlighter-rouge"&gt;Enum&lt;/code&gt; module. The &lt;code class="highlighter-rouge"&gt;Enum&lt;/code&gt; module allow us to enumerate the built-in ranges, lists, sets, etc:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [2, 4, 6]&lt;/span&gt;

&lt;span class="n"&gt;range&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;
&lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;range&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [2, 4, 6]&lt;/span&gt;

&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;HashSet&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [2, 4, 6]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Not only that, any developer can &lt;strong&gt;extend&lt;/strong&gt; the &lt;code class="highlighter-rouge"&gt;Enum&lt;/code&gt; module to work with any data type as long as the data type implements &lt;a href="https://hexdocs.pm/elixir/Enumerable.html"&gt;the &lt;code class="highlighter-rouge"&gt;Enumerable&lt;/code&gt; protocol&lt;/a&gt; (protocols in Elixir are based on Clojure’s protocol). This is extremely convenient because the developer needs to know only the &lt;code class="highlighter-rouge"&gt;Enum&lt;/code&gt; API for enumeration, instead of memorizing specific APIs for sets, lists, dicts, etc.&lt;/p&gt;

&lt;p&gt;There are many other protocols exposed by the language, like &lt;a href="https://hexdocs.pm/elixir/Inspect.html"&gt;the &lt;code class="highlighter-rouge"&gt;Inspect&lt;/code&gt; protocol&lt;/a&gt; for pretty printing data structures and &lt;a href="https://hexdocs.pm/elixir/Access.html"&gt;the &lt;code class="highlighter-rouge"&gt;Access&lt;/code&gt; protocol&lt;/a&gt; for accessing key-value data by key. By being extensible, Elixir ensures developers can work &lt;strong&gt;with&lt;/strong&gt; the language, instead of &lt;strong&gt;against&lt;/strong&gt; the language.&lt;/p&gt;

&lt;h2 id="summing-up"&gt;Summing up&lt;/h2&gt;

&lt;p&gt;The goal of this post was to sumarize the language goals: compatibility, productivity and extensibility. By being compatibile with the Erlang VM, we are providing developers another toolset for building concurrent, distributed and fault-tolerant systems.&lt;/p&gt;

&lt;p&gt;We also hope to have clarified what Elixir brings to the Erlang VM, in particular, meta-programming through macros, polymorphic constructs for extensibility and a data-focused standard library with extensible and consistent APIs for diverse types, including strict and lazy enumeration, unicode handling, a test framework and more.&lt;/p&gt;

&lt;p&gt;Give Elixir a try! You can start with our &lt;a href="/getting-started/introduction.html"&gt;getting started guide&lt;/a&gt;, or check out our sidebar for other learning resources.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v0.10.0 released</title>
    <link href="http://elixir-lang.org/blog/2013/07/13/elixir-v0-10-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2013-07-13T00:00:00+00:00</updated>
    <id>/blog/2013/07/13/elixir-v0-10-0-released</id>
    <content type="html">&lt;p&gt;Elixir v0.10.0 is released with support for streams, sets and many improvements to the Mix and ExUnit applications.&lt;/p&gt;

&lt;h2 id="streams"&gt;Streams&lt;/h2&gt;

&lt;p&gt;The default mechanism for working with collections in Elixir is the &lt;code class="highlighter-rouge"&gt;Enum&lt;/code&gt; module. With it, you can map over ranges, lists, sets, dictionaries and any other structure as long as it implements the &lt;code class="highlighter-rouge"&gt;Enumerable&lt;/code&gt; protocol:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [2, 4, 6]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;code class="highlighter-rouge"&gt;Enum&lt;/code&gt; module performs eager evaluation. Consider the following example:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;take_while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [2, 4]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In the example above, we enumerate the items in list once, taking all elements that are less than 3, and then we enumerate the remaining elements again, multiplying them by two. In order to retrieve the final result, we have created one intermediate list. As we add more operations, more intermediate lists will be generated.&lt;/p&gt;

&lt;p&gt;This approach is simple and efficient for the majority of the cases but, when working with large collections, we can generate many, possibly large, intermediate lists affecting performance. That’s one of the problems Streams solve. Let’s rewrite the example above using Streams:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;take_while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; #Stream.Lazy&amp;lt;...&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now, instead of getting the result back, we got a Stream. The list elements are yet to be enumerated! We can realize the stream  by calling any of the Enum functions, like &lt;code class="highlighter-rouge"&gt;Enum.to_list/1&lt;/code&gt;. By doing so the list will be iterated just once avoiding the intermediary representations.&lt;/p&gt;

&lt;p&gt;In a nutshell, Streams are composable, lazy enumerables. Streams are also useful when doing IO or expressing infinite computations. We can retrieve a file as a stream:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;File&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stream!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;README.md"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In the example above, we got a stream that will enumerate the lines in the file one by one when enumerated. We could further extend the stream above, for example, by rejecting blank lines, and the file will be opened just when its results are actually needed.&lt;/p&gt;

&lt;p&gt;Do you need a random number generator? We got your back:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;Stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;repeatedly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="ss"&gt;:random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;uniform&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;take&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [0.4435846174457203, 0.7230402056221108, 0.94581636451987]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class="highlighter-rouge"&gt;Stream.repeatedly/1&lt;/code&gt; returns an infinite stream but that’s ok we just need its first three elements. You can learn more about &lt;a href="https://hexdocs.pm/elixir/Stream.html"&gt;stream and related functions in &lt;code class="highlighter-rouge"&gt;Stream&lt;/code&gt; module documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="sets"&gt;Sets&lt;/h2&gt;

&lt;p&gt;This release also adds &lt;a href="https://hexdocs.pm/elixir/Set.html"&gt;the Sets API&lt;/a&gt; to Elixir and a HashSet implementation. The HashSet implementation follows &lt;a href="/blog/2013/01/27/elixir-v0-8-0-released/"&gt;the same design goals as the HashDict implementation&lt;/a&gt; released at the beginning of this year, starting with a compact representation and expanding and contracting as needed.&lt;/p&gt;

&lt;p&gt;This feature was a contribution from &lt;a href="https://github.com/josephwilk"&gt;Joseph Wilk&lt;/a&gt; and he talks about its implementation and provides some benchmarks &lt;a href="http://blog.josephwilk.net/elixir/sets-in-elixir.html"&gt;on his blog&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="pretty-printing"&gt;Pretty printing&lt;/h2&gt;

&lt;p&gt;Another addition to this release is pretty printing. The pretty printing started as an implementation of the &lt;a href="http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf"&gt;Wadler paper&lt;/a&gt; by &lt;a href="https://github.com/manpages"&gt;Jonns Mostovoys&lt;/a&gt; which was then improved by &lt;a href="https://github.com/brunoro"&gt;Gustavo Brunoro&lt;/a&gt; under his Google Summer of Code project as described in &lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200"&gt;Lindig’s &lt;em&gt;Strictly Prettier&lt;/em&gt; paper&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As soon as you upgrade to Elixir v0.10.0 and start IEx, you will get pretty printing for all data structures provided by Elixir. We have also added documentation to the &lt;code class="highlighter-rouge"&gt;Inspect&lt;/code&gt; module about &lt;a href="https://hexdocs.pm/elixir/Inspect.html"&gt;adding pretty printing to your own structures&lt;/a&gt; as well as &lt;a href="https://hexdocs.pm/elixir/Inspect.Algebra.html"&gt;using the document algebra for any other kind of formatting&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="other-improvements"&gt;Other improvements&lt;/h2&gt;

&lt;p&gt;Other notable improvements are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;We have improved Mix to be able to fetch Rebar dependencies, making integration with the existing Erlang ecossystem much easier, thanks to &lt;a href="https://github.com/ericmj"&gt;Eric Meadows-Jonsson&lt;/a&gt;;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ExUnit now supports the trace option, enabled via &lt;code class="highlighter-rouge"&gt;mix test --trace&lt;/code&gt;, which forces tests to run sequentially and print the test names and extra information as it goes;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We are also working hard on Windows support, improving its command-line tools and working towards a green test suite, thanks to &lt;a href="https://github.com/tojans"&gt;Tom Jansens&lt;/a&gt;;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Meta-programming in Elixir was also improved by the addition of the &lt;code class="highlighter-rouge"&gt;binding/0&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;binding/1&lt;/code&gt; macros plus the additions of &lt;code class="highlighter-rouge"&gt;Macro.expand_once/2&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Macro.expand_all/2&lt;/code&gt; to the &lt;a href="https://hexdocs.pm/elixir/Macro.html"&gt;&lt;code class="highlighter-rouge"&gt;Macro&lt;/code&gt; module&lt;/a&gt;;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are also improvements to typespecs, error messages, many bug fixes and some backwards incompatible changes. We have posted a detailed &lt;a href="https://groups.google.com/forum/?fromgroups#!topic/elixir-lang-talk/ksrefrgK1eY"&gt;upgrade instructions on the mailing list&lt;/a&gt;. For a general overview, &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.10.0/CHANGELOG.md"&gt;check out the CHANGELOG&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Give Elixir a try! You can start with our &lt;a href="/getting-started/introduction.html"&gt;getting started guide&lt;/a&gt;, or check out our sidebar for other learning resources.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v0.9.0 released</title>
    <link href="http://elixir-lang.org/blog/2013/05/23/elixir-v0-9-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2013-05-23T00:00:00+00:00</updated>
    <id>/blog/2013/05/23/elixir-v0-9-0-released</id>
    <content type="html">&lt;p&gt;While &lt;a href="https://pragprog.com/book/elixir/programming-elixir"&gt;Programming Elixir&lt;/a&gt; was being announced, we have been working on Elixir v0.9.0 which is finally out. This release contains new features, important performance optimizations and bug fixes.&lt;/p&gt;

&lt;p&gt;Elixir v0.9.0 also removes support for Erlang R15 and earlier versions. In case you still need to run Elixir software on R15, we have also released Elixir v0.8.3, which contains many of the enhancements in v0.9.0. Check the &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.9.0/CHANGELOG.md"&gt;CHANGELOG for more details for both releases&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All this work was achieved by our very vibrant community! Over the last month, 17 authors have pushed more than 500 commits, where more than 60 pull requests were merged and more than 80 issues were closed.&lt;/p&gt;

&lt;p&gt;Let’s talk about the goodies!&lt;/p&gt;

&lt;h2 id="compilation-time-improvements"&gt;Compilation time improvements&lt;/h2&gt;

&lt;p&gt;We have spent some time improving compilation time. The particular scenario we have worked on was the definition of records:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defrecord&lt;/span&gt; &lt;span class="no"&gt;User&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;name:&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;age:&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Records are a good scenario because they are implemented in Elixir, using Elixir macros, and they also define a module underneath, which exercises the Erlang VM compilation stack.&lt;/p&gt;

&lt;p&gt;We have used &lt;a href="http://www.erlang.org/doc/man/fprof.html"&gt;fprof&lt;/a&gt; to identify the bottlenecks and made the compilation stack 35% faster. We have also identified bottlenecks coming from Erlang and &lt;a href="https://github.com/erlang/otp/commit/32b194495f353dde014b00008a630eeff2a71056"&gt;pushed some patches&lt;/a&gt; that should benefit both Elixir and Erlang code.&lt;/p&gt;

&lt;p&gt;A special thanks to &lt;a href="https://github.com/yrashk"&gt;Yurii Rashkovskii&lt;/a&gt; for the data and profiling.&lt;/p&gt;

&lt;h2 id="umbrella-projects"&gt;Umbrella projects&lt;/h2&gt;

&lt;p&gt;In Elixir, an application denotes a component implementing some specific functionality, that can be started and stopped as a unit, and which can be re-used in other systems as well.&lt;/p&gt;

&lt;p&gt;As a project grows, it is recommended to break it apart into smaller, isolated applications and bundle them together. The issue so far was that Elixir did not provide good support for working with many applications at once, and compiling and managing those applications became rather a tedious work.&lt;/p&gt;

&lt;p&gt;Elixir v0.9.0 now supports umbrella projects which can work with many applications at the same time. You can create a new umbrella project with:&lt;/p&gt;

&lt;div class="language-bash highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;mix new my_project --umbrella
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The generated project will have the following structure:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;apps/
mix.exs
README.md
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now, inside the &lt;code class="highlighter-rouge"&gt;apps&lt;/code&gt; directory, you can create as many applications as you want and running &lt;code class="highlighter-rouge"&gt;mix compile&lt;/code&gt; inside the umbrella project will automatically compile all applications. The &lt;a href="https://github.com/elixir-lang/elixir/issues/667"&gt;original discussion for this feature&lt;/a&gt; contains more details about how it all works.&lt;/p&gt;

&lt;p&gt;A special thanks to &lt;a href="https://github.com/ericmj"&gt;Eric Meadows-Jonsson&lt;/a&gt; for implementing this feature and to &lt;a href="https://github.com/yrashk"&gt;Yurii&lt;/a&gt; for testing it against different edge cases.&lt;/p&gt;

&lt;h2 id="reducers"&gt;Reducers&lt;/h2&gt;

&lt;p&gt;Elixir v0.9.0 changes its main abstraction for enumeration from iterators to reducers. Before Elixir v0.9.0, when you invoked:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;Enum&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [1, 4, 9]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;It asked the &lt;code class="highlighter-rouge"&gt;Enum.Iterator&lt;/code&gt; protocol for instructions on how to iterate the list &lt;code class="highlighter-rouge"&gt;[1, 2, 3]&lt;/code&gt;. This iteration happened by retrieving each item in the list, one by one, until there were no items left.&lt;/p&gt;

&lt;p&gt;This approach posed many problems:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Iterators are very hard to compose;&lt;/li&gt;
  &lt;li&gt;Iterators contain state. You need to know, at each moment, what is the next element you have to iterate next. We use functions and their bindings to pass the iteration state around;&lt;/li&gt;
  &lt;li&gt;Iterators have the “dangling open resource” problem. Consider that you want to iterate a file with &lt;code class="highlighter-rouge"&gt;Enum.map/2&lt;/code&gt; as above. If any step during the iteration fails, there is no easy way to notify the resource being iterated  (in this case, the opened file) that iteration failed, so we can’t close the file automatically, leaving it to the user.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Reducers solve all of those problems by using a more functional approach. Instead of asking a list to spill its elements out one by one and then working on each element, we now generate a recipe of computations and pass it down to the list which applies those computations on itself.&lt;/p&gt;

&lt;p&gt;Here is how we implement the &lt;code class="highlighter-rouge"&gt;Enumerable&lt;/code&gt; protocol for lists:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defimpl&lt;/span&gt; &lt;span class="no"&gt;Enumerable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;for:&lt;/span&gt; &lt;span class="no"&gt;List&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;do_reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;do_reduce&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;do_reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;do_reduce&lt;/span&gt;&lt;span class="p"&gt;([],&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;acc&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The implementation above works as a simple &lt;code class="highlighter-rouge"&gt;reduce&lt;/code&gt; function (also called &lt;code class="highlighter-rouge"&gt;fold&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;inject&lt;/code&gt; or &lt;code class="highlighter-rouge"&gt;foldl&lt;/code&gt; in other languages). Here is how it works:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="c1"&gt;# Sum all elements in a list&lt;/span&gt;
&lt;span class="no"&gt;Enumerable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; 6&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;code class="highlighter-rouge"&gt;Enum.map/2&lt;/code&gt; we have used above is now implemented in terms of this reducing function:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;Enum&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;collection&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="no"&gt;Enumerable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;collection&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;reverse&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This approach solves all the problems above:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Reducers are composable (notice how we have implemented map on top of reduce by composing functions);&lt;/li&gt;
  &lt;li&gt;Reducers are self-contained: there is no need keep state around, which also solves the “dangling open resource” problem. The data type now knows exactly when the iteration starts and when it finishes;&lt;/li&gt;
  &lt;li&gt;Reducers do not dictate how a type should be enumerated. This means types like &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;HashDict&lt;/code&gt; can provide a much faster implementation for Reducers;&lt;/li&gt;
  &lt;li&gt;Furthermore, the end result is a cleaner implementation of most of &lt;code class="highlighter-rouge"&gt;Enum&lt;/code&gt; functions (the &lt;a href="https://github.com/elixir-lang/elixir/pull/1102"&gt;reducers pull request&lt;/a&gt; removes over 500LOC) and better performance!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Reducers also opens up room for lazy and parallel enumeration, as &lt;a href="http://clojure.com/blog/2012/05/08/reducers-a-library-and-model-for-collection-processing.html"&gt;the Clojure community has already proven&lt;/a&gt; and something we are looking forward to explore on upcoming releases.&lt;/p&gt;

&lt;p&gt;A special thanks to &lt;a href="https://github.com/ericmj"&gt;Eric Meadows-Jonsson&lt;/a&gt; for implementing this feature!&lt;/p&gt;

&lt;h2 id="other-bits"&gt;Other bits&lt;/h2&gt;

&lt;p&gt;We have also many other smaller improvements:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Our CLI now supports &lt;code class="highlighter-rouge"&gt;--hidden&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;--cookie&lt;/code&gt; flags which are useful for distributed modes;&lt;/li&gt;
  &lt;li&gt;Our test framework, ExUnit, is now able to capture all the communication that happens with a registed IO device, like &lt;code class="highlighter-rouge"&gt;:stdio&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;:stderr&lt;/code&gt;, via &lt;a href="https://hexdocs.pm/ex_unit/ExUnit.CaptureIO.html"&gt;&lt;code class="highlighter-rouge"&gt;ExUnit.CaptureIO&lt;/code&gt;&lt;/a&gt;. This is very useful for testing how your software reacts to some inputs and what it prints to the terminal;&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;IEx&lt;/code&gt; now allows files to be imported into the shell with &lt;code class="highlighter-rouge"&gt;import_file&lt;/code&gt; and also loads &lt;code class="highlighter-rouge"&gt;~/.iex&lt;/code&gt; on startup for custom configuration;&lt;/li&gt;
  &lt;li&gt;The &lt;code class="highlighter-rouge"&gt;String&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;Enum&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Dict&lt;/code&gt; modules got more convenience functions that goes from checking unicode character validity to taking values out of a dictionary;&lt;/li&gt;
  &lt;li&gt;And many, many more!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A huge thank you to our community for sending bug reports, providing bug fixes and contributing all those amazing features. And when are &lt;strong&gt;you&lt;/strong&gt; joining us? :)&lt;/p&gt;

&lt;p&gt;Give Elixir a try! You can start with our &lt;a href="/getting-started/introduction.html"&gt;getting started guide&lt;/a&gt;, or &lt;a href="https://www.youtube.com/watch?v=a-off4Vznjs&amp;amp;feature=youtu.be"&gt;check this 30 minute video from PragProg&lt;/a&gt; or buy the beta version of &lt;a href="https://pragprog.com/book/elixir/programming-elixir"&gt;Programming Elixir&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir on Xen</title>
    <link href="http://elixir-lang.org/blog/2013/05/02/elixir-on-xen/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2013-05-02T00:00:00+00:00</updated>
    <id>/blog/2013/05/02/elixir-on-xen</id>
    <content type="html">&lt;p&gt;Elixir uses Erlang underneath, all the way down. Thanks to this, an Elixir project can run on the recently revealed “OS-less” Erlang VM called LING VM. LING VM is the core technology of &lt;a href="http://erlangonxen.org"&gt;Erlang on Xen&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="why-xen"&gt;Why Xen?&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Xen"&gt;Xen&lt;/a&gt; is an open-source baremetal hypervisor that allows many operating systems to run on the same hardware. Xen is frequently used for server virtualization, Infrastructure as a Service (IaaS) and security applications.&lt;/p&gt;

&lt;p&gt;Elixir on Xen runs on top of the Xen Hypervisor (via the LING VM) but with no traditional OS underneath it, taking away numerous administrative, scalability, and performance issues. This  limits options of a malicious attacker, making it an excellent choice for high-security applications, and reduces startup latency, allowing developers to spawn new VMs in less than 100 miliseconds.&lt;/p&gt;

&lt;p&gt;You can learn more about Xen and the LING VM on the &lt;a href="http://erlangonxen.org"&gt;Erlang on Xen website&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="getting-started"&gt;Getting started&lt;/h2&gt;

&lt;p&gt;In order to run Elixir on the LING VM, you need to produce a Xen image of your Elixir project. This can be done with the help of the &lt;a href="https://github.com/maximk/lingex"&gt;lingex project&lt;/a&gt;, created by the LING VM team.&lt;/p&gt;

&lt;p&gt;Producing an Elixir image using the free Erlang on Xen Build Service requires just a few steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Add a dependency on &lt;code class="highlighter-rouge"&gt;lingex&lt;/code&gt; to your &lt;code class="highlighter-rouge"&gt;mix.exs&lt;/code&gt; file:&lt;/p&gt;

    &lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;   def deps do
     [ { :lingex, github: "maximk/lingex" } ]
   end
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Run &lt;code class="highlighter-rouge"&gt;mix deps.get&lt;/code&gt; to update your dependencies. This adds a few custom tasks
to the mix tool (&lt;code class="highlighter-rouge"&gt;lingex.build&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;lingex.image&lt;/code&gt;, and &lt;code class="highlighter-rouge"&gt;lingex.build_image&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Set &lt;code class="highlighter-rouge"&gt;lingex&lt;/code&gt; options. Add the following lines to your &lt;code class="highlighter-rouge"&gt;mix.exs&lt;/code&gt; file:&lt;/p&gt;

    &lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;   def project do
     [ lingex_opts: [
         build_host: "build.erlangonxen.org:8080",
   			username: "test",
   			password: "test" ] ]
   end
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Optionally, you may register with the build service &lt;a href="http://build.erlangonxen.org/register"&gt;here&lt;/a&gt; and update the credentials accordingly. For the complete list of recognized options see the build service documentation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Run &lt;code class="highlighter-rouge"&gt;mix lingex.build_image&lt;/code&gt;. This will archive all &lt;code class="highlighter-rouge"&gt;*.beam&lt;/code&gt; files of your project and submit them to the build service.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The build process will complete in about 30s. An image file called ‘vmling’ will appear in the current directory, ready to boot as a Xen guest. The image file will contain LING VM and your project code.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And this is all. Erlang on Xen is going to boot the Erlang VM and the standard Erlang shell. You can access Elixir shell in a couple steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In the Erlang shell, first start IEx:&lt;/p&gt;

    &lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;   1&amp;gt; application:start(iex).
   ok
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Then hit &lt;code class="highlighter-rouge"&gt;Ctrl+G&lt;/code&gt;. This will open up the user switch command interface from the Erlang shell.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In the user switch interface, type:&lt;/p&gt;

    &lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;   User switch command
    --&amp;gt; s 'Elixir.IEx'
    --&amp;gt; c
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This will bring you to Interactive Elixir and you can execute Elixir expressions as usual!&lt;/p&gt;

&lt;h2 id="summing-up"&gt;Summing up&lt;/h2&gt;

&lt;p&gt;Running Elixir on Xen opens up many possibilities to Elixir developers. We are very thankful for the work done by &lt;a href="http://erlangonxen.org"&gt;Erlang on Xen team&lt;/a&gt;, who added support for Elixir and the &lt;code class="highlighter-rouge"&gt;lingex&lt;/code&gt; build tool.&lt;/p&gt;

&lt;p&gt;Erlang on Xen (and consequently Elixir on Xen) is still in active development, so don’t forget to read more about its concepts, use cases and limitations on &lt;a href="http://erlangonxen.org/"&gt;Erlang on Xen website&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v0.8.2 released</title>
    <link href="http://elixir-lang.org/blog/2013/04/29/elixir-v0-8-2-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2013-04-29T00:00:00+00:00</updated>
    <id>/blog/2013/04/29/elixir-v0-8-2-released</id>
    <content type="html">&lt;p&gt;The past week we have released Elixir v0.8.2. It contains many bug fixes and better support for Erlang R16, including &lt;a href="https://github.com/elixir-lang/elixir/commit/0fad1883df9da541628e8485d28372fd4b977b89"&gt;the new built-in functions &lt;code class="highlighter-rouge"&gt;insert_elem/3&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;delete_elem/2&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We have also added extensive support to ANSI escape codes. For example, by simply upgrading to the latest Elixir you will get colored output from your test suites:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/contents/exunit-ansi.png" alt="ANSI escape with ExUnit" /&gt;&lt;/p&gt;

&lt;p&gt;We have also added colored output to Interactive Elixir (IEx) but it requires Erlang R16.&lt;/p&gt;

&lt;p&gt;Finally, Elixir has always given special attention to documentation. You can easily document functions with the &lt;code class="highlighter-rouge"&gt;@doc&lt;/code&gt; attribute:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;Math&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="nv"&gt;@doc&lt;/span&gt; &lt;span class="sd"&gt;"""
  Add two numbers together.

  ## Examples

      iex&amp;gt; Math.add(1, 2)
      3

  """&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The documentation above is embedded into the module and can be easily retrieved at runtime. For example, by typing &lt;code class="highlighter-rouge"&gt;h Math.add/2&lt;/code&gt; into Interactive Elixir, we can access the documentation for that module.&lt;/p&gt;

&lt;p&gt;Elixir v0.8.2 takes this to the next level by adding support to doctests. Given the example above, you can configure Elixir to automatically run the code samples in your documentation by including a call to the &lt;code class="highlighter-rouge"&gt;doctest&lt;/code&gt; macro in your test suite:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmodule&lt;/span&gt; &lt;span class="no"&gt;MathTest&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="no"&gt;ExUnit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Case&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;async:&lt;/span&gt; &lt;span class="no"&gt;true&lt;/span&gt;
  &lt;span class="n"&gt;doctest&lt;/span&gt; &lt;span class="no"&gt;Math&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can learn more about &lt;a href="https://hexdocs.pm/ex_unit/ExUnit.DocTest.html"&gt;doctests on our documentation page&lt;/a&gt; and get more information about our latest release &lt;a href="https://github.com/elixir-lang/elixir/blob/ed27611f48ba150404c95fe15f1d6058a4287330/CHANGELOG.md"&gt;on the CHANGELOG&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you are new to Elixir, &lt;a href="/getting-started/introduction.html"&gt;it’s easy to get started with&lt;/a&gt;!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Google Summer of Code 2013</title>
    <link href="http://elixir-lang.org/blog/2013/04/19/google-summer-of-code-2013/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2013-04-19T00:00:00+00:00</updated>
    <id>/blog/2013/04/19/google-summer-of-code-2013</id>
    <content type="html">&lt;p&gt;We are pleased to announce that Elixir is taking part in Google Summer of Code 2013
as member of the &lt;a href="http://beamcommunity.github.io"&gt;BEAM Community&lt;/a&gt;. This means that
students all around the world can get paid to work on Elixir during the summer!&lt;/p&gt;

&lt;p&gt;The rules require students to be enrolled in college full or part-time, and to be
at least 18 years by May 27, 2013. You can find more information on
&lt;a href="http://www.google-melange.com/gsoc/homepage/google/gsoc2013"&gt;Google Summer of Code 2013 website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We have published &lt;a href="https://github.com/beamcommunity/beamcommunity.github.com/wiki/Project:-Elixir"&gt;a list of ideas we would like to see and explore in Elixir&lt;/a&gt;
that students can use as a basis, but students are also free to send their own
proposals. If your proposal gets accepted, Google will pay you $5000 over the
course of three months to work on Elixir. Students can start submitting their
proposals on April 22 and the deadline is May 23.&lt;/p&gt;

&lt;p&gt;Note the BEAM Community serves as a mentoring organization for many other projects
that run on the Erlang VM, including Elixir. To see the full list, &lt;a href="http://beamcommunity.github.io"&gt;visit the website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We hope to work with you during this summer! If you have more questions, feel free
to join the &lt;a href="https://groups.google.com/d/forum/beam-community"&gt;BEAM Community mailing list&lt;/a&gt;
or talk to us on &lt;code class="highlighter-rouge"&gt;#beam-community&lt;/code&gt; on irc.freenode.net.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v0.8.0 released</title>
    <link href="http://elixir-lang.org/blog/2013/01/27/elixir-v0-8-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2013-01-27T00:00:00+00:00</updated>
    <id>/blog/2013/01/27/elixir-v0-8-0-released</id>
    <content type="html">&lt;p&gt;On the last 9th January, we celebrated &lt;a href="https://github.com/elixir-lang/elixir/commit/337c3f2d569a42ebd5fcab6fef18c5e012f9be5b"&gt;two years since Elixir’s first commit&lt;/a&gt; and to celebrate this occasion we have prepared a big release. Elixir v0.8 is out, with documentation, optimizations, bug fixes and shiny new features. Let’s take a look at them!&lt;/p&gt;

&lt;h2 id="otp-applications"&gt;OTP applications&lt;/h2&gt;

&lt;p&gt;One of the goals for the v0.8 release was better integration with OTP applications. By passing the &lt;code class="highlighter-rouge"&gt;--sup&lt;/code&gt; option to Mix, you can start a new OTP Application containing application callbacks and a supervisor:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;mix new my_app --sup
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And applications can be started directly from the command line as well:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;elixir --app my_app
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We have written a whole &lt;a href="/getting-started/mix-otp/supervisor-and-application.html"&gt;guide chapter about creating OTP applications, supervisors and servers&lt;/a&gt;. Give it a try!&lt;/p&gt;

&lt;h2 id="improved-unicode-support"&gt;Improved Unicode support&lt;/h2&gt;

&lt;p&gt;Elixir favors the use of UTF-8 binaries since its first release. In the latest releases, we took it up a notch by adding Unicode support, built upon the Unicode Standard 6.2.0. Elixir v0.8 takes this even further, adding more convenience functions and better support to named sequences:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="no"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capitalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;ﬁN"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;#=&amp;gt; "Fin"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The example above contains a string with only two codepoints, &lt;a href="http://www.fileformat.info/info/unicode/char/FB01/index.htm"&gt;the codepoint ﬁ&lt;/a&gt; and &lt;a href="http://www.fileformat.info/info/unicode/char/006E/index.htm"&gt;the codepoint n&lt;/a&gt;. Look how Elixir properly capitalizes the string, returning a new string made of three codepoints (all ascii letters).&lt;/p&gt;

&lt;p&gt;Learn more about &lt;a href="https://hexdocs.pm/elixir/String.html"&gt;Unicode support with the String module&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="ast-metadata"&gt;AST metadata&lt;/h2&gt;

&lt;p&gt;As per this release, Elixir AST nodes can contain metadata. This metadata is compilation time only but may allow macros to annotate important information in AST nodes, like line numbers, file and other library specific information. If you quote an Elixir expression, we can see the metadata slot:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="kn"&gt;quote&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;world"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;world"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In the example above, we can see the AST representation of the expression &lt;code class="highlighter-rouge"&gt;hello("world")&lt;/code&gt;. It is made of a tuple of three elements, the first one is the function name represented by the atom &lt;code class="highlighter-rouge"&gt;:hello&lt;/code&gt;, the second one is a keyword list containing metadata (in this case, no metadata is available) and the third is a list of arguments, containing the string “world”.&lt;/p&gt;

&lt;p&gt;By default, &lt;code class="highlighter-rouge"&gt;quote&lt;/code&gt; does not annotate line numbers, but we can pass it as an option:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="kn"&gt;quote&lt;/span&gt; &lt;span class="ss"&gt;line:&lt;/span&gt; &lt;span class="n"&gt;__ENV__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;world"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;line:&lt;/span&gt; &lt;span class="m"&gt;9&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sd"&gt;"&lt;/span&gt;&lt;span class="s2"&gt;world"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now, we can see the metadata spot being used to annotate the line number. This change allowed us to take our macros one step further…&lt;/p&gt;

&lt;h2 id="macros-expansion"&gt;Macros expansion&lt;/h2&gt;

&lt;p&gt;Prior to this release, Elixir had limited expansion of imports and aliases. We decided this would be an important issue to tackle in this release, as people are building more and more projects on top of Elixir.&lt;/p&gt;

&lt;p&gt;Imagine you manually implemented &lt;code class="highlighter-rouge"&gt;unless&lt;/code&gt; as a macro, that does the opposite of &lt;code class="highlighter-rouge"&gt;if&lt;/code&gt;:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;defmacro&lt;/span&gt; &lt;span class="k"&gt;unless&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;quote&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;!unquote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="kn"&gt;unquote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;When some code call the &lt;code class="highlighter-rouge"&gt;unless&lt;/code&gt; macro above, in previous Elixir versions, it would expect the &lt;code class="highlighter-rouge"&gt;if&lt;/code&gt; macro to be available at the caller. This may not be necessarily true and, even worse, another implementation of the &lt;code class="highlighter-rouge"&gt;if&lt;/code&gt; macro, not compatible to the one above, could be available.&lt;/p&gt;

&lt;p&gt;Elixir v0.8 ensures that the &lt;code class="highlighter-rouge"&gt;unless&lt;/code&gt; macro above will expand to the same &lt;code class="highlighter-rouge"&gt;if&lt;/code&gt; macro available when quoted, guaranteeing different libraries can integrate easily without imposing hidden requirements.&lt;/p&gt;

&lt;p&gt;You can read more about &lt;a href="/getting-started/case-cond-and-if.html"&gt;macros in the getting started guide&lt;/a&gt; or &lt;a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2"&gt;go deep into the quote macro docs&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="a-new-way-to-manipulate-pathnames"&gt;A new way to manipulate pathnames&lt;/h2&gt;

&lt;p&gt;Elixir v0.8 contains a bit of house cleaning too. We have created &lt;a href="https://hexdocs.pm/elixir/Path.html"&gt;the Path module&lt;/a&gt; to accommodate functions used to manipulate filesystem paths and have also added functions like &lt;a href="https://hexdocs.pm/elixir/System.html"&gt;&lt;code class="highlighter-rouge"&gt;System.tmp_dir&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;System.user_home&lt;/code&gt;&lt;/a&gt; which are meant to work accross different operating systems and are very handy when scripting.&lt;/p&gt;

&lt;h2 id="the-new-hashdict"&gt;The new HashDict&lt;/h2&gt;

&lt;p&gt;For last but not least, Elixir ships with a &lt;a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/hash_dict.ex"&gt;new HashDict implementation&lt;/a&gt;. In Erlang, there are different key-value store implementations and often you need to pick which one is the best for you based on the average size of the dictionary. Generally speaking, &lt;a href="http://www.erlang.org/doc/man/orddict.html"&gt;orddicts&lt;/a&gt; are efficient and fast when you want to hold a handful of items, otherwise you should consider &lt;a href="http://www.erlang.org/doc/man/gb_trees.html"&gt;gb_trees&lt;/a&gt; unless you want to hold thousands of items, when then &lt;a href="http://www.erlang.org/doc/man/dict.html"&gt;dict&lt;/a&gt; becomes your best option. The fact those implementations do not provide the same API, makes it harder to change your code when you realize another implementation would be better fit.&lt;/p&gt;

&lt;p&gt;For Elixir, we decided to have a single dictionary implementation that would scale as needed. It would start as a compact representation for a handful of items and expand and rehash accordingly as new items are added or removed, providing fast access and modification times on all ranges. We are glad to say our goals were reached and a new &lt;code class="highlighter-rouge"&gt;HashDict&lt;/code&gt; implementation ships with Elixir v0.8.&lt;/p&gt;

&lt;p&gt;Let’s take a look at some benchmarks:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/contents/hash-dict-fetch.png" alt="Comparison of fetch times with string keys" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/contents/hash-dict-update.png" alt="Comparison of update times with string keys" /&gt;&lt;/p&gt;

&lt;p&gt;For each number of keys, we have measured and normalized those values against &lt;code class="highlighter-rouge"&gt;HashDict&lt;/code&gt; results. This way it is easy to see which implementation takes more or less time compared to Elixir’s implementation.&lt;/p&gt;

&lt;p&gt;&lt;code class="highlighter-rouge"&gt;orddict&lt;/code&gt; is still the faster representation for small ranges since it is a simple list. However, &lt;code class="highlighter-rouge"&gt;HashDict&lt;/code&gt; is able to be relatively fast compared to &lt;code class="highlighter-rouge"&gt;orddict&lt;/code&gt; for those small ranges and the fastest solution once you have dozens of keys. &lt;a href="https://gist.github.com/436a9d2bca5051a6dfab"&gt;Those results can be verified when using other types as keys as well&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, given &lt;code class="highlighter-rouge"&gt;HashDict&lt;/code&gt; starts with a compact representation, it also takes less memory. Compared to the &lt;code class="highlighter-rouge"&gt;dict&lt;/code&gt; implementation, an empty &lt;code class="highlighter-rouge"&gt;HashDict&lt;/code&gt; takes only 5 words, while &lt;code class="highlighter-rouge"&gt;dict&lt;/code&gt; takes 47.&lt;/p&gt;

&lt;h2 id="wrapping-up"&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;We continue actively working on Elixir and this release is the &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.8.0/CHANGELOG.md"&gt;result of our efforts on different areas&lt;/a&gt;! We have exciting plans and newer possibilities to explore, as a new release of Erlang OTP also comes out in a couple weeks.&lt;/p&gt;

&lt;p&gt;Also, we previously announced Elixir is going to be released frequently, every 2 to 4 weeks. We have made a small detour to get v0.8.0 out of the door, but we are back to our regular schedule as of today!&lt;/p&gt;

&lt;p&gt;&lt;a href="/getting-started/introduction.html"&gt;Celebrate with us and give Elixir a try&lt;/a&gt;!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v0.7.2 released</title>
    <link href="http://elixir-lang.org/blog/2012/12/04/elixir-v0-7-2-released/"/>
    <author>
      <name>Yurii Rashkovskii</name>
    </author>
    <updated>2012-12-04T00:00:00+00:00</updated>
    <id>/blog/2012/12/04/elixir-v0-7-2-released</id>
    <content type="html">&lt;p&gt;Hot out of the oven! We just released Elixir v0.7.2 with a number of delicious improvements.&lt;/p&gt;

&lt;p&gt;One of the most important changes in this minor release is a partial rehaul of
the type specification syntax.&lt;/p&gt;

&lt;p&gt;Here’s the gist:&lt;/p&gt;

&lt;div class="language-elixir highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="nv"&gt;@spec&lt;/span&gt; &lt;span class="n"&gt;myfun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;
&lt;span class="c1"&gt;# becomes&lt;/span&gt;
&lt;span class="nv"&gt;@spec&lt;/span&gt; &lt;span class="n"&gt;myfun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;

&lt;span class="nv"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;
&lt;span class="c1"&gt;# becomes&lt;/span&gt;
&lt;span class="nv"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;any&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;any&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;any&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# becomes&lt;/span&gt;
&lt;span class="nv"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(()&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# becomes&lt;/span&gt;
&lt;span class="nv"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# becomes&lt;/span&gt;
&lt;span class="nv"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Another change is that Mix now echoes the output of external tools
such as git and rebar, and handles exit status correctly. This have previously
led to some less-than-perfect workflows.&lt;/p&gt;

&lt;p&gt;We’ve also added a more compact and visual form of the &lt;code class="highlighter-rouge"&gt;function&lt;/code&gt; helper. Now,
instead of &lt;code class="highlighter-rouge"&gt;function(Enum, :all?, 2)&lt;/code&gt; you can use &lt;code class="highlighter-rouge"&gt;function(Enum.all?/2)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We’ve also figured out how to achieve an up to 6x &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.7.2/lib/elixir/lib/kernel.ex#L1386-L1417"&gt;performance increase&lt;/a&gt;
under some circunstances when using records.&lt;/p&gt;

&lt;p&gt;…and &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.7.2/CHANGELOG.md"&gt;many other fixes &amp;amp; improvements&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lastly, but not least importantly, I’d like to mention that we’re very excited about how the community around Elixir is building up. Thank you all for being around and supporting us!&lt;/p&gt;

&lt;p&gt;&lt;a href="/getting-started/introduction.html"&gt;Learn more about Elixir&lt;/a&gt;!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v0.7.1 released</title>
    <link href="http://elixir-lang.org/blog/2012/11/18/elixir-v0-7-1-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2012-11-18T00:00:00+00:00</updated>
    <id>/blog/2012/11/18/elixir-v0-7-1-released</id>
    <content type="html">&lt;p&gt;Elixir v0.7.1 was released this weekend to celebrate the end of a two months journey traveling around Europe, United States and Brazil talking about and exposing Elixir to new developers.&lt;/p&gt;

&lt;p&gt;This is a minor release that contains a couple enhancements regarding UTF-8, &lt;a href="http://www.erlang.org/doc/man/dialyzer.html"&gt;dialyzer&lt;/a&gt; support and bug fixes.&lt;/p&gt;

&lt;p&gt;During this time traveling around, we have spoken at many conferences, as &lt;a href="http://thestrangeloop.com/"&gt;Strange Loop&lt;/a&gt;, &lt;a href="http://oredev.org/"&gt;Øredev&lt;/a&gt;, &lt;a href="http://qconsp.com/"&gt;QCon SP&lt;/a&gt; and &lt;a href="http://rupy.eu/"&gt;Rupy&lt;/a&gt; as well as at different companies. Developers from different backgrounds have shown interest in Elixir, &lt;a href="http://spin.atomicobject.com/2012/10/31/elixir-erlang-and-the-dining-philosophers/"&gt;written about it&lt;/a&gt;, joined us at #elixir-lang on freenode and contributed to the language. As of today, Elixir is powered by 51 different contributors!&lt;/p&gt;

&lt;p&gt;In case you missed any of those conferences, &lt;a href="https://vimeo.com/53221562"&gt;the talk I presented at Øredev is available and you can watch it now&lt;/a&gt;. The slides are also available below.&lt;/p&gt;

&lt;p&gt;If you want to hear more about Elixir at a conference or an event, please let us know. Thank you and don’t forget to &lt;a href="/getting-started/introduction.html"&gt;give Elixir a try&lt;/a&gt;!&lt;/p&gt;

&lt;script async="" class="speakerdeck-embed" data-id="cf4727401449013077d112313d1a82a3" data-ratio="1.2994923857868" src="//speakerdeck.com/assets/embed.js"&gt;&lt;/script&gt;

</content>
  </entry>
  <entry>
    <title>Elixir v0.7.0 released</title>
    <link href="http://elixir-lang.org/blog/2012/10/20/elixir-v0-7-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2012-10-20T00:00:00+00:00</updated>
    <id>/blog/2012/10/20/elixir-v0-7-0-released</id>
    <content type="html">&lt;p&gt;Elixir v0.7.0 was released with bug fixes and many improvements, like a &lt;code class="highlighter-rouge"&gt;String&lt;/code&gt; module to handle UTF-8 binaries and support to environments and nested dependencies in Mix.&lt;/p&gt;

&lt;p&gt;We have also taken important steps into normalizing our APIs. In Erlang, accesses to tuple and lists are one-based and binaries are zero-based, but in Elixir we have normalized all of them to rely on zero-based access.&lt;/p&gt;

&lt;p&gt;This release also includes some backwards incompatible changes, but the majority of changes were first deprecated, meaning your code will run just fine but with warnings. Those warnings will be removed in the next release v0.7.1, which should happen in a 2 to 4 weeks time span.&lt;/p&gt;

&lt;p&gt;For more information, read out the &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.7.0/CHANGELOG.md"&gt;CHANGELOG&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thank you and don’t forget to &lt;a href="/getting-started/introduction.html"&gt;give Elixir a try&lt;/a&gt;!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v0.6.0 released</title>
    <link href="http://elixir-lang.org/blog/2012/08/01/elixir-v0-6-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2012-08-01T00:00:00+00:00</updated>
    <id>/blog/2012/08/01/elixir-v0-6-0-released</id>
    <content type="html">&lt;p&gt;We have finally released &lt;a href="/"&gt;Elixir&lt;/a&gt; v0.6.0! This release includes a build tool called Mix, support for Erlang typespecs, many improvements to IEx and improved IO, File and Macro support.&lt;/p&gt;

&lt;h2 id="whats-new"&gt;What’s new&lt;/h2&gt;

&lt;p&gt;When &lt;a href="/blog/2012/05/25/elixir-v0-5-0-released/"&gt;we released version v0.5.0&lt;/a&gt;, we have set three major goals for release v0.6.0:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Provide a build tool that makes it easy to create, compile and test Elixir projects;&lt;/li&gt;
  &lt;li&gt;Support &lt;a href="http://www.erlang.org/doc/reference_manual/typespec.html"&gt;Erlang typespecs&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;Improve IO and File modules to be more robust and complete.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Our interactive shell (IEx) also had many improvements, thanks to the Elixir developer community. We now have easy access to documentation, remote shells, autocomplete and much more. In order to show you a bit of what you can do in this release, we have prepared a short (~6 min) screencast:&lt;/p&gt;

&lt;iframe src="https://player.vimeo.com/video/46709928" class="video" width="600" height="337" allowfullscreen=""&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href="https://vimeo.com/46709928"&gt;Elixir v0.6 quick tour - Mix and IEx&lt;/a&gt; from &lt;a href="https://vimeo.com/user3182384"&gt;Plataformatec&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That’s it. For the next months, we will continue improving Elixir (you can see some ideas floating around in the &lt;a href="https://github.com/elixir-lang/elixir/issues"&gt;issues tracker&lt;/a&gt;) but we will start to focus on other tools and libraries for the community.&lt;/p&gt;

&lt;p&gt;Thank you and don’t forget to &lt;a href="/getting-started/introduction.html"&gt;give Elixir a try&lt;/a&gt;!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir v0.5.0 released</title>
    <link href="http://elixir-lang.org/blog/2012/05/25/elixir-v0-5-0-released/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2012-05-25T00:00:00+00:00</updated>
    <id>/blog/2012/05/25/elixir-v0-5-0-released</id>
    <content type="html">&lt;p&gt;We have finally released &lt;a href="/"&gt;Elixir&lt;/a&gt; v0.5.0! This marks the first release since the language was rewritten. In this blog post, we will discuss what we achieved during this time and what are the next steps!&lt;/p&gt;

&lt;p&gt;If you don’t care about any of these, you can go straight to our &lt;a href="/getting-started/introduction.html"&gt;Getting Started guide&lt;/a&gt;. If you do, keep on reading!&lt;/p&gt;

&lt;h2 id="looking-back"&gt;Looking back&lt;/h2&gt;

&lt;p&gt;I have started working in Elixir at the beginning of 2011. Around April that year, I had released the version v0.3.0 that was stable enough for me to start using in my own projects. However, after using it in a couple projects quickly reviewed that I was not happy with some of the design decisions taken early on.&lt;/p&gt;

&lt;p&gt;At that time, Elixir attempted to be a considerable departure from Erlang and that revealed very fast to a bad design decision because, in order to use any Erlang module, we first would have to provide an Elixir wrapper for it. Any new function or module in new Erlang releases would have to be wrapped first in Elixir, which means we would always play catch up with Erlang.&lt;/p&gt;

&lt;p&gt;After not feeling productive enough with that Elixir version, I have decided to take a break from Elixir to study old, new and emerging languages. The challenge was to not re-invent Erlang as a language, but how to provide the productivity and flexibility I expect from Elixir while staying a 100% compatible with Erlang.&lt;/p&gt;

&lt;p&gt;It was around October 2011, during a short stay in San Francisco, that I came up with what would be &lt;a href="https://github.com/josevalim/lego-lang"&gt;the foundation of Elixir’s current version&lt;/a&gt; with the help of Yehuda Katz. Development of the new Elixir version started a few days before 2012 and continued steady when the new year came in.&lt;/p&gt;

&lt;p&gt;Around February of that year, feeling confident enough about the direction the language was moving (and initial benchmarks I had made at that point), I have pitched Elixir to &lt;a href="http://plataformatec.com.br/"&gt;my company, Plataformatec&lt;/a&gt;, and they have accepted to sponsor Elixir. With their help, Elixir developed even faster and that’s what we are going to take a look next.&lt;/p&gt;

&lt;h2 id="where-we-are"&gt;Where we are&lt;/h2&gt;

&lt;p&gt;One of the goals we have set was to have a good website and documentation before the next official release. With the help of the Plataformatec team, we created a logo for Elixir and put this website live.&lt;/p&gt;

&lt;p&gt;At the same time, &lt;a href="https://bitbucket.org/birkenfeld/pygments-main/pull-request/57/add-elixir-and-elixir-console-lexers"&gt;we were working on pygments support&lt;/a&gt;, a &lt;a href="https://github.com/elixir-lang/ex_doc"&gt;documentation generation tool&lt;/a&gt; and many others. Soon, Github was able to syntax highlight Elixir code and &lt;a href="/"&gt;our API documentation was online&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;At the same time, people started to gather around #elixir-lang channel on irc.freenode.net and &lt;a href="https://github.com/elixir-lang/elixir/tree/master/lib/mix"&gt;play with Elixir&lt;/a&gt;, &lt;a href="https://github.com/guedes/exdate"&gt;start their&lt;/a&gt; &lt;a href="https://github.com/yrashk/validatex"&gt;own projects&lt;/a&gt; and &lt;a href="https://github.com/alco/elixir/wiki/Erlang-Syntax:-A-Crash-Course"&gt;tutorials&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Although the initial release was scheduled to April 2012, the feedback from such early developers forced us to review some design and syntax decisions and were extremely important to shape the language as it is today.&lt;/p&gt;

&lt;p&gt;With v0.5.0 finally out, we are committing to a stable syntax and a basic standard library. In the last couple days before the release, we have been working on streamlining the documentation and ensure Elixir works on Mac, Linux and Windows machines!&lt;/p&gt;

&lt;h2 id="looking-forward"&gt;Looking forward&lt;/h2&gt;

&lt;p&gt;There are still many, many things to do! In the next months, we will continue working on growing our community, talks and other documentation material. A huge thanks to &lt;a href="https://twitter.com/true_droid"&gt;Alexei Sholik&lt;/a&gt; who is moving this area forward.&lt;/p&gt;

&lt;p&gt;We will also work on better integration and documentation on building Erlang systems. Erlang ships with the &lt;a href="https://en.wikipedia.org/wiki/Open_Telecom_Platform"&gt;Open Telecom Platform&lt;/a&gt; which provides many tools to build distributed applications. In v0.5.0, all these tools are already available but we want to make the build process even simpler.&lt;/p&gt;

&lt;p&gt;In parallel, we will improve our &lt;a href="https://github.com/elixir-lang/ex_doc"&gt;documentation generation tool&lt;/a&gt; and &lt;a href="https://github.com/elixir-lang/elixir/tree/master/lib/mix"&gt;build tool&lt;/a&gt; which will likely be merged into core when they are solid enough.&lt;/p&gt;

&lt;p&gt;Finally, we will continue improving the Standard Library. Although Elixir’s goal is to rely on Erlang the most as possible, we also want to provide a small Standard Library which makes better use of Elixir semantics. For the next weeks, we will focus on improving the IO and File manipulation modules. New data types may also appear, for example, ranges come to my mind.&lt;/p&gt;

&lt;p&gt;Check out our &lt;a href="/"&gt;home page&lt;/a&gt; and the &lt;a href="/getting-started/introduction.html"&gt;getting started guide&lt;/a&gt; for more information. Welcome aboard and grab a cup of Elixir, because you are certainly going to enjoy the ride!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>A peek inside Elixir's Parallel Compiler</title>
    <link href="http://elixir-lang.org/blog/2012/04/24/a-peek-inside-elixir-s-parallel-compiler/"/>
    <author>
      <name>José Valim</name>
    </author>
    <updated>2012-04-24T00:00:00+00:00</updated>
    <id>/blog/2012/04/24/a-peek-inside-elixir-s-parallel-compiler</id>
    <content type="html">&lt;p&gt;Today, a parallel compiler just landed in Elixir master. The goal of the parallel compiler is to compile files in parallel, automatically detecting dependencies between files. In this blog post, we are going to take a peek into the parallel compiler internals and learn more about Erlang and Elixir in the process.&lt;/p&gt;

&lt;h2 id="process-based-serial-compilation"&gt;Process-based serial compilation&lt;/h2&gt;

&lt;p&gt;The idea of the parallel compiler is very simple: for each file we want to compile, we will spawn a new process that will be responsible for its compilation. When compilation finishes, the process is going to send a message to the main process (the one responsible for coordinating compilation) that compilation finished so a new file can be compiled.&lt;/p&gt;

&lt;p&gt;In Elixir, we could write this code as follows:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;def spawn_compilers([current | files], output) do
  parent = Process.self()
  child  = spawn_link(fn -&amp;gt;
    :elixir_compiler.file_to_path(current, output)
    send parent, { :compiled, Process.self() }
  end)
  receive do
    { :compiled, ^child } -&amp;gt;
      spawn_compilers(files, output)
    { :EXIT, ^child, { reason, where } } -&amp;gt;
      :erlang.raise(:error, reason, where)
  end
end

def spawn_compilers([], _output) do
  :done
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In the first line, we define a function named &lt;code class="highlighter-rouge"&gt;spawn_compilers&lt;/code&gt; that receives two arguments, the first is a list of files to compile and the second is a string telling us where to write the compiled file. The first argument is represented as a list with head and tail (&lt;code class="highlighter-rouge"&gt;[current | files]&lt;/code&gt;) where the top of the list is assigned to &lt;code class="highlighter-rouge"&gt;current&lt;/code&gt; and the remaining items to &lt;code class="highlighter-rouge"&gt;files&lt;/code&gt;. If the list is empty, the first clause of &lt;code class="highlighter-rouge"&gt;spawn_compilers&lt;/code&gt; is not going to match, the clause &lt;code class="highlighter-rouge"&gt;spawn_compilers([], _output)&lt;/code&gt; defined at the end will instead.&lt;/p&gt;

&lt;p&gt;Inside &lt;code class="highlighter-rouge"&gt;spawn_compilers&lt;/code&gt;, we first retrieve the PID of the current process with &lt;code class="highlighter-rouge"&gt;Process.self&lt;/code&gt; (remember we are talking about Erlang processes/actors and not OS processes) and then proceed to spawn a new process to execute the given function in parallel. Spawning a new process is done with the &lt;code class="highlighter-rouge"&gt;spawn_link&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;The &lt;code class="highlighter-rouge"&gt;spawn_link&lt;/code&gt; function starts a new process and automatically links the current (parent) process with the spawned (child) one, returning the child PID. By linking the process we ensure that, if the child process dies, a message will be sent to the parent process which then can act on it.&lt;/p&gt;

&lt;p&gt;The function given to &lt;code class="highlighter-rouge"&gt;spawn_link&lt;/code&gt; is quite straight-forward. It simply invokes an Erlang function as &lt;code class="highlighter-rouge"&gt;:elixir_compiler.file_to_path&lt;/code&gt; and then proceeds to send a message to the parent process notifying that compilation finished.&lt;/p&gt;

&lt;p&gt;After the child process is spawned, we invoke the &lt;code class="highlighter-rouge"&gt;receive&lt;/code&gt; macro and start waiting for messages. At this point, we are expecting two types of messages:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class="highlighter-rouge"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:compiled,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;^child&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt; - a message sent by the child informing us that compilation finished. Note that use of &lt;code class="highlighter-rouge"&gt;^&lt;/code&gt; before the variable &lt;code class="highlighter-rouge"&gt;child&lt;/code&gt; to tell Elixir to match the current value of &lt;code class="highlighter-rouge"&gt;child&lt;/code&gt; with the one received in the message. If compilation succeeds, we move forward and spawn the next child by calling &lt;code class="highlighter-rouge"&gt;spawn_compilers&lt;/code&gt; recursively;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class="highlighter-rouge"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:EXIT,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;^child,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;reason,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;where&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;/code&gt; - this is the message sent by the child process in case it dies. This message is only received if the child is started via &lt;code class="highlighter-rouge"&gt;spawn_link&lt;/code&gt;. In the message, we can find the reason why it failed and the stacktrace. We then proceed to call an Erlang internal function to re-raise the error in the main process, effectively stopping compilation.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With this code, we were able to compile each file inside a different process. However, notice that we are not yet compiling in parallel. Every time we spawn a child process, we wait until it succeeds (or fails) before moving to the next step. We are going to eventually compile files in parallel, but before we reach to this point, let’s understand the problem of dependencies between files.&lt;/p&gt;

&lt;h2 id="dependency-between-files"&gt;Dependency between files&lt;/h2&gt;

&lt;p&gt;Imagine that we have two files, &lt;code class="highlighter-rouge"&gt;a.ex&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;b.ex&lt;/code&gt;, with the following contents:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;# a.ex
defmodule A do
  B.define
end

# b.ex
defmodule B do
  defmacro define do
    quote do
      def one, do: 1
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In order to compile &lt;code class="highlighter-rouge"&gt;A&lt;/code&gt;, we need to ensure that &lt;code class="highlighter-rouge"&gt;B&lt;/code&gt; is already compiled and loaded so we can invoke the &lt;code class="highlighter-rouge"&gt;define&lt;/code&gt; macro. This means the file &lt;code class="highlighter-rouge"&gt;a.ex&lt;/code&gt; depends on the file &lt;code class="highlighter-rouge"&gt;b.ex&lt;/code&gt;. When compiling files in parallel, we want to be able to detect such cases and automatically handle them.&lt;/p&gt;

&lt;p&gt;The way we are going to handle this is by pausing compilation every time a module that was not yet defined is invoked. In this case, when compiling the file &lt;code class="highlighter-rouge"&gt;a.ex&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;B.define&lt;/code&gt; is invoked, the process responsible for compiling &lt;code class="highlighter-rouge"&gt;a.ex&lt;/code&gt; is going to pause and notify our main process. The main process will then start the compilation of other files. Whenever the module &lt;code class="highlighter-rouge"&gt;B&lt;/code&gt; is compiled, the main process is going to tell the process responsible for &lt;code class="highlighter-rouge"&gt;a.ex&lt;/code&gt; to resume compilation since its dependency &lt;code class="highlighter-rouge"&gt;B&lt;/code&gt; is now available.&lt;/p&gt;

&lt;p&gt;In order to customize this process, we are going to take a look at Erlang’s error handler.&lt;/p&gt;

&lt;h2 id="custom-error-handler"&gt;Custom error handler&lt;/h2&gt;

&lt;p&gt;By default, Elixir (and Erlang) code is autoloaded. This means that, if we invoke &lt;code class="highlighter-rouge"&gt;List.delete&lt;/code&gt; and the module &lt;code class="highlighter-rouge"&gt;List&lt;/code&gt; was not loaded yet, the Erlang VM is going to look into the &lt;code class="highlighter-rouge"&gt;ebin&lt;/code&gt; directory (the directory where we put compiled files) and try to load it. This process is controlled by the &lt;a href="http://www.erlang.org/doc/man/error_handler.html"&gt;&lt;code class="highlighter-rouge"&gt;error_handler&lt;/code&gt; module in Erlang&lt;/a&gt; via two callback functions: &lt;code class="highlighter-rouge"&gt;undefined_function&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;undefined_lambda&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As discussed in the previous section, we want to extend the error handler to actually stop the currently running process whenever a module is not found and resume the process only after we ensure the module is compiled. To do that, we can simply define our own error handler and ask Erlang to use it. Our custom error handler is defined as follows:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;defmodule Elixir.ErrorHandler do
  def undefined_function(module, fun, args) do
    ensure_loaded(module)
    :error_handler.undefined_function(module, fun, args)
  end

  def undefined_lambda(module, fun, args) do
    ensure_loaded(module)
    :error_handler.undefined_lambda(module, fun, args)
  end

  defp ensure_loaded(module) do
    case Code.ensure_loaded(module) do
      { :module, _ } -&amp;gt;
        []
      { :error, _ } -&amp;gt;
        parent = Process.get(:elixir_parent_compiler)
        send parent, { :waiting, Process.self, module }
        receive do
          { :release, ^parent } -&amp;gt; ensure_loaded(module)
        end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Our error handler defines two public functions. Both those functions are callbacks required to be implemented by the error handler. They simply call &lt;code class="highlighter-rouge"&gt;ensure_loaded(module)&lt;/code&gt; and then delegate the remaining logic to Erlang’s original &lt;code class="highlighter-rouge"&gt;error_handler&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The private &lt;code class="highlighter-rouge"&gt;ensure_loaded&lt;/code&gt; function calls &lt;code class="highlighter-rouge"&gt;Code.ensure_loaded(module)&lt;/code&gt; which checks if the given module is loaded and, if not, tries to load it. In case it succeeds, it returns &lt;code class="highlighter-rouge"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:module,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;_&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;, which means the module is available and we don’t need to stop the current process. However, if it returns &lt;code class="highlighter-rouge"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:error,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;_&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;, it means the module cannot be found and we need to wait until it is compiled. For that, we invoke &lt;code class="highlighter-rouge"&gt;Process.get(:elixir_parent_compiler)&lt;/code&gt; to get the PID of the main process so we can notify it that we are waiting on a given module. Then we invoke the macro &lt;code class="highlighter-rouge"&gt;receive&lt;/code&gt; as a way to stop the current process until we receive a message from the parent saying new modules are available, starting the flow again.&lt;/p&gt;

&lt;p&gt;With our error handler code in place, the first thing we need to do is to change the function given to &lt;code class="highlighter-rouge"&gt;spawn_link&lt;/code&gt; to use the new error handler:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;spawn_link(fn -&amp;gt;
  Process.put(:elixir_parent_compiler, parent)
  Process.flag(:error_handler, Elixir.ErrorHandler)

  :elixir_compiler.file_to_path(current, output)
  send parent, { :compiled, Process.self() }
end)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Notice that we have two small additions. First we store the &lt;code class="highlighter-rouge"&gt;:elixir_parent_compiler&lt;/code&gt; PID in the process dictionary so we are able to read it from the error handler and then we proceed to configure a flag in our process so our new error handler is invoked whenever a module or function cannot be found.&lt;/p&gt;

&lt;p&gt;Second, our main process can now receive a new &lt;code class="highlighter-rouge"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:waiting,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;child,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt; message, so we need to extend it to account for those messages. Not only that, we need to control which PIDs we have spawned so we can notify them whenever a new module is compiled, forcing us to add a new argument to the &lt;code class="highlighter-rouge"&gt;spawn_compilers&lt;/code&gt; function. &lt;code class="highlighter-rouge"&gt;spawn_compilers&lt;/code&gt; would then be rewritten as follows:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;def spawn_compilers([current | files], output, stack) do
  parent = Process.self()
  child  = spawn_link(fn -&amp;gt;
    :elixir_compiler.file_to_path(current, output)
    send parent, { :compiled, Process.self() }
  end)
  wait_for_messages(files, output, [child | stack])
end

# No more files and stack is empty, we are done
def spawn_compilers([], _output, []) do
  :done
end

# No more files and stack is not empty, wait for all messages
def spawn_compilers([], output, stack) do
  wait_for_messages([], output, stack)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Notice we added an extra clause to &lt;code class="highlighter-rouge"&gt;spawn_compilers&lt;/code&gt; so we can properly handle the case where we don’t have more files to spawn but we are still waiting for processes in the stack. We have also moved our &lt;code class="highlighter-rouge"&gt;receive&lt;/code&gt; logic to a new private function called &lt;code class="highlighter-rouge"&gt;wait_for_messages&lt;/code&gt;, implemented as follows:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;defp wait_for_messages(files, output, stack) do
  receive do
    { :compiled, child } -&amp;gt;
      new_stack = List.delete(stack, child)
      Enum.each new_stack, fn(pid) -&amp;gt;
        send pid, { :release, Process.self }
      end
      spawn_compilers(files, output, new_stack)
    { :waiting, _child, _module } -&amp;gt;
      spawn_compilers(files, output, stack)
    { :EXIT, _child, { reason, where } } -&amp;gt;
      :erlang.raise(:error, reason, where)
  after
    10_000 -&amp;gt;
      raise "dependency on unexesting module or possible deadlock"
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The implementation for &lt;code class="highlighter-rouge"&gt;wait_for_messages&lt;/code&gt; is now broken into 4 clauses:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class="highlighter-rouge"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:compiled,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;child&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt; - Similar as before, it is the notification a child processed finished compilation. Every time we receive such notifications, we remove the child PID from the stack and notify the remaining PIDs in the stack that new modules are available. Notice that we no longer match on a specific &lt;code class="highlighter-rouge"&gt;^child&lt;/code&gt; PID, since now we can receive messages from different children at the same time;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class="highlighter-rouge"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:waiting,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;_child,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;_module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt; - A message received every time a child process is waiting on a module to be compiled. In this scenario, all we do is spawn a new process to compile another file, ensuring compilation is never blocked;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class="highlighter-rouge"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:EXIT,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;_child,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;reason,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;where&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;/code&gt; - The same behaviour as before, it simply raises an error if any of the child processes fail;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class="highlighter-rouge"&gt;after: 10_000&lt;/code&gt; - This clause is going to be invoked whenever the main process does not receive a message for 10 seconds. This means a file depends on a module that does not exist (and therefore waits forever) or there is a cyclic dependency;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And that’s all we need to have a basic version of our parallel compilation working. Notice we start compiling only one file at a time but, as soon as we depend on other files, the number of PIDs in the stack starts to grow. If we wanted, we could modify the code to make use of a head start and compile more than one file since the beginning.&lt;/p&gt;

&lt;p&gt;It is important to notice that this code has room for improvements. First, every time a new module is compiled, we notify all child process that new modules are available. This is a waste of resource if we consider that the child modules tells us explicitly on which modules they are waiting on. Therefore, the code could be modified to store a mapping from each child process to the module it is waiting for so that when a new module is compiled, only the children that depend on it are notified.&lt;/p&gt;

&lt;p&gt;Also, if we start storing which module each process is depending on, we are able to know whenever we have a deadlock or a dependency on an nonexistent file, allowing us to get rid of the timeout.&lt;/p&gt;

&lt;p&gt;All those improvements and other goodies like callbacks are implemented in Elixir source code and we recommend you take a look at both the &lt;a href="https://github.com/elixir-lang/elixir/blob/6182602f1205e2d9fc54666e0721270a27226fbc/lib/elixir/parallel_compiler.ex"&gt;Elixir.ParallelCompiler&lt;/a&gt; and &lt;a href="https://github.com/elixir-lang/elixir/blob/6182602f1205e2d9fc54666e0721270a27226fbc/lib/elixir/error_handler.ex"&gt;Elixir.ErrorHandler&lt;/a&gt; modules to see all the details firsthand.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
</feed>
